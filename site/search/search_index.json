{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Finitewave","text":"<p>Finitewave is a Python package for simulating cardiac electrophysiology using finite-difference methods. It provides tools for modeling and visualizing the propagation of electrical waves in cardiac tissue, making it ideal for researchers and engineers in computational biology, bioengineering, and related fields.</p>"},{"location":"#why-finitewave","title":"Why Finitewave?","text":"<p>Because of its simplicity and availability. Finitewave is the most simple and user-friendly framework for cardiac simulation, supporting a rich set of tools that make it accessible to both beginners and advanced users alike.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Simulate 2D and 3D cardiac tissue models, including the ability to handle   complex geometries.</li> <li>Simulate conditions such as fibrosis and infarction. </li> <li>Built-in models, including the Aliev-Panfilov, TP06, Luo-Rudy91 models.</li> <li>Trackers for measuring various aspects of the simulation (LATs, EGMs, Action   potentials, etc.). </li> <li>Visualization tools for analyzing wave propagation.</li> <li>Customize simulation parameters to suit specific research needs.</li> <li>High-performance computing with support for GPU acceleration (currently under   development).</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install Finitewave, navigate to the root directory of the project and run:</p> <pre><code>python -m build\npip install dist/finitewave-&lt;version&gt;.whl\n</code></pre> <p>This will install Finitewave as a Python package on your system.</p> <p>For development purposes, you can install the package in an editable mode, which allows changes to be immediately reflected without reinstallation:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"Dependency Version* Link numpy 1.26.4 https://numpy.org numba 0.59.0 https://numba.pydata.org scipy 1.11.4 https://scipy.org matplotlib 3.8.3 https://matplotlib.org tqdm 4.65.0 https://github.com/tqdm pyvista 0.44.1 https://pyvista.org <p>*Versions listed are the most recent tested versions.</p> <p>If you want to use the <code>AnimationBuilder</code> to create MP4 animations, ensure that ffmpeg is installed on your system.</p>"},{"location":"api/","title":"API Reference","text":"<ul> <li>PotentialPeriodAnimationBuilder</li> <li>DriftVelocityCalculation</li> <li>AnimationBuilder</li> <li>StimSequence</li> <li>Animation3DBuilder</li> <li>VisMeshBuilder3D</li> <li>VTKMeshBuilder</li> <li>Stencil</li> <li>CardiacTissue</li> <li>TrackerSequence</li> <li>Tracker</li> <li>StateKeeper</li> <li>Stim</li> <li>StimVoltage</li> <li>StimCurrent</li> <li>StimSequence</li> <li>CardiacModel</li> <li>Command</li> <li>CommandSequence</li> <li>IncorrectWeightsShapeError</li> <li>FibrosisPattern</li> <li>IsotropicStencil3D</li> <li>AsymmetricStencil3D</li> <li>RotationalAnisotropy</li> <li>CardiacTissue3D</li> <li>PeriodMap3DTracker</li> <li>VTKFrame3DTracker</li> <li>Velocity3DTracker</li> <li>Variable3DTracker</li> <li>ECG3DTracker</li> <li>Spiral3DTracker</li> <li>ActivationTime3DTracker</li> <li>ActionPotential3DTracker</li> <li>AnimationSlice3DTracker</li> <li>Period3DTracker</li> <li>Animation3DTracker</li> <li>StimCurrentCoord3D</li> <li>StimVoltageCoord3D</li> <li>StimCurrentMatrix3D</li> <li>StimVoltageMatrix3D</li> <li>TP063D</li> <li>TP06Kernels3D</li> <li>LuoRudy913D</li> <li>LuoRudy91Kernels3D</li> <li>AlievPanfilovKernels3D</li> <li>AlievPanfilov3D</li> <li>Diffuse3DPattern</li> <li>Structural3DPattern</li> <li>IsotropicStencil2D</li> <li>AsymmetricStencil2D</li> <li>CardiacTissue2D</li> <li>ActionPotential2DTracker</li> <li>MultiVariable2DTracker</li> <li>ActivationTime2DTracker</li> <li>Spiral2DTracker</li> <li>ECG2DTracker</li> <li>Animation2DTracker</li> <li>Period2DTracker</li> <li>Variable2DTracker</li> <li>Velocity2DTracker</li> <li>PeriodMap2DTracker</li> <li>MultiActivationTime2DTracker</li> <li>StimCurrentCoord2D</li> <li>StimVoltageCoord2D</li> <li>StimCurrentMatrix2D</li> <li>StimVoltageMatrix2D</li> <li>AlievPanfilovKernels2D</li> <li>AlievPanfilov2D</li> <li>LuoRudy912D</li> <li>LuoRudy91Kernels2D</li> <li>TP062D</li> <li>TP06Kernels2D</li> <li>IncorrectWeightsModeError2D</li> <li>ScarGauss2DPattern</li> <li>Structural2DPattern</li> <li>Diffuse2DPattern</li> <li>ScarRect2DPattern</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#getting-started","title":"Getting Started","text":"<p>Here's a simple example to get you started:</p> <pre><code>\n   import finitewave as fw\n\n   n = 100\n\n   # Initialize a 100x100 simulation mesh\n   tissue = fw.CardiacTissue2D([n, n])\n   tissue.mesh = np.ones([n, n]) # Set all nodes to 1 (cardiomyocytes)\n   tissue.add_boundaries() # Make the border nodes empty\n\n   # Use Aliev-Panfilov model to perform simulation\n   model = fw.AlievPanfilov2D()\n   # Setup numerical parameters:\n   model.dt = 0.01  # time step\n   model.dr = 0.25  # spatial step\n   model.t_max = 5  # simulation time\n\n   # Setup stimulation\n   stim_sequence = fw.StimSequence()\n   # Set one stimul (u = 1) at the beginning of the simulation on the edge of \n   # the tissue (line with length n and width 3)  \n   stim_sequence.add_stim(fw.StimVoltageCoord2D(0, 1, 0, n, 0, 3))\n   # Set the tissue and stimulation sequence to the model\n   model.cardiac_tissue = tissue\n   model.stim_sequence = stim_sequence\n\n   model.run()\n\n   # Display the potential map at the end of the simulation\n   plt.imshow(model.u)\n   plt.show()\n\n</code></pre>"},{"location":"getting_started/#minimal-script-requirements","title":"Minimal script requirements","text":"<p>To create a simulation script using Finitewave, ensure you include the following minimal set of components:</p>"},{"location":"getting_started/#cardiactissue","title":"CardiacTissue","text":"<p>Set up the mesh, fibers array, stencil, and conductivity array.</p> <ul> <li> <p><code>mesh</code>: Mesh contains cells (nodes) that represent the cardiac tissue.   Each cell can be assigned a value to represent the type of tissue   (cardiomyocytes, fibrotic tissue, and boundary). Ensure that every mesh   contains a border line of empty nodes (boundary) by using <code>add_boundaries()</code>   method.</p> </li> <li> <p><code>stencil</code>: Choose between a 9-point stencil (anisotropic) or a 5-point   stencil (orthotropic or isotropic). The stencil calculates weights for the   divergence kernels. While the 9-point stencil is general-purpose, using   the 5-point stencil is more performance-efficient in orthotropic and   isotropic diffusion cases.</p> </li> <li> <p><code>conductivity</code>: This array of coefficients (default: 1) to simulate   propagation speed. This is the simpliest (but not the only) way to model   fibrotic tissue.</p> </li> </ul>"},{"location":"getting_started/#model-configuration","title":"Model Configuration","text":"<p>Create and configure the model with a minimal set of parameters:</p> <ul> <li><code>dt</code> (time step)</li> <li><code>dr</code> (spatial step)</li> <li><code>t_max</code> (maximum simulation time).</li> </ul>"},{"location":"getting_started/#stimulation-parameters","title":"Stimulation Parameters","text":"<p>Use <code>Stim</code> classes to define the stimulation area and add them to the <code>StimSequence</code> class object.</p> <p>For example (for 2D simulations):</p> <ul> <li><code>StimVoltageCoord2D(stim_time, voltage, x0, x1, y0, y1)</code></li> <li><code>StimCurrentCoord2D(stim_time, current, current_time, x0, x1, y0, y1)</code></li> <li>Run the simulation using the <code>run()</code> method.</li> </ul>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#cardiactissue","title":"CardiacTissue","text":"<p>The <code>CardiacTissue</code> class is used to represent myocardial tissue and its structural properties in simulations. It includes several key attributes that define the characteristics and behavior of the cardiac mesh used in finite-difference calculations.</p>"},{"location":"overview/#mesh","title":"Mesh","text":"<p>The mesh attribute of the <code>CardiacTissue</code> class is a 2D or 3D array that represents the structure of the cardiac tissue. Each element of the mesh represents a cell in the tissue, with different values assigned to different types of tissue:</p> <ul> <li>Cardiomyocytes: Represented by a value of 1.</li> <li>Fibrotic tissue: Represented by a value of 2.</li> <li>Empty nodes (boundary): Represented by a value of 0.</li> </ul> <p>The mesh can be initialized with a specific size and shape using the <code>CardiacTissue2D</code> or <code>CardiacTissue3D</code> classes. The mesh can be modified by setting the values of individual cells or by using the <code>add_boundaries()</code> method to add a border of empty nodes around the tissue.</p>"},{"location":"overview/#conductivity","title":"Conductivity","text":"<p>The <code>conductivity</code> attribute of the <code>CardiacTissue</code> class is an array that assigns different conductivities to different regions of the mesh. This allows users to simulate the effects of fibrosis on wave propagation in the heart by modifying the conductivity values in the tissue.</p>"},{"location":"overview/#fibrosis","title":"Fibrosis","text":"<p>Fibrosis is a common feature of cardiac tissue that can be modeled in simulations using Finitewave.</p> <ul> <li> <p>Fibrotic tissue is represented by a conductivity array, which assigns    different conductivities to different regions of the mesh. This allows users   to simulate the effects of fibrosis on wave propagation in the heart.</p> </li> <li> <p>Another way to model fibrosis is to set <code>mesh</code> values to 2 (empty nodes).</p> </li> </ul>"},{"location":"overview/#fibers","title":"Fibers","text":"<p>By default, Finitewave uses an isotropic conduction model, where the conductivity is the same in all directions. And the fibers are not used in the simulation. The default stencil is <code>IsotropicStencil2D</code> or <code>IsotropicStencil3D</code>, which is used to calculate the weights for the divergence kernels in the finite-difference scheme.</p> <p>To simulate anisotropic conduction, users can define the orientation of cardiac fibers in the tissue. This is done by setting the <code>fibers</code> attribute of the <code>CardiacTissue</code> object to an array of vectors with <code>fibers.shape == mesh.shape + (dim,)</code> that represent the orientation of fibers at each node in the mesh. For 2D simulations, the fibers array should have shape <code>(n, n, 2)</code>. For 3D simulations, the fibers array should have shape <code>(n, n, n, 3)</code>.</p> <p>To use the fibers in the simulation, set the <code>stencil</code> attribute of the tissue to <code>AsymmetricStencil2D</code> or <code>AsymmetricStencil3D</code>. Using the <code>AsymmetricStencil</code> is more time-consuming than the <code>IsotropicStencil</code>. For example, <code>AsymmetricStencil2D</code> requires 9-point stencil calculations vs. 5-point stencil calculations for <code>IsotropicStencil</code>.</p> <p>To set diffusion coefficients in the direction of fibers, use the <code>D_al</code> and <code>D_ac</code> attributes of the tissue. For Aliev-Panfilov model, <code>D_al = 1</code> and <code>D_ac = D_al / 9</code>.</p>"},{"location":"overview/#models","title":"Models","text":"<p>Finitewave provides several built-in models for simulating cardiac electrophysiology:</p> <ul> <li>Aliev-Panfilov model</li> <li>TP06 model</li> <li>Luo-Rudy91 model</li> </ul> <p>These models can be used to simulate the propagation of electrical waves in cardiac tissue and study the effects of different conditions on wave propagation.</p>"},{"location":"overview/#stimulation","title":"Stimulation","text":"<p>Stimulation is an essential aspect of cardiac electrophysiology simulations. Finitewave provides several classes for defining and applying stimulation to the tissue:</p> <ul> <li><code>StimVoltageCoord2D</code>: Stimulate a region of the tissue with a voltage.</li> <li><code>StimCurrentCoord2D</code>: Stimulate a region of the tissue with a current.</li> <li><code>StimVoltageMatrix2D</code>: Stimulate the tissue with a matrix with the same   shape as the <code>tissue.mesh</code>. The stimulation will be applied to the cells   with non-zero values.</li> <li><code>StimCurrentMatrix2D</code>: Stimulate the tissue with a matrix with the same   shape as the <code>tissue.mesh</code>. The stimulation current will be applied to   the cells with non-zero values.</li> </ul> <p>Stimulation can be applied to the tissue using the <code>StimSequence</code> class, which allows users to define a sequence of stimulations to be applied at specific times during the simulation.</p>"},{"location":"overview/#trackers","title":"Trackers","text":"<p>Trackers are used to measure various aspects of the simulation, such as local activation times (LATs), electrogram signals (EGMs), and action potentials, etc. Finitewave provides several built-in trackers for measuring these properties:</p> <ul> <li><code>ActivationTimeTracker</code>: Measure local activation times (LATs) in the tissue.</li> <li><code>MultiActivationTimeTracker</code>: Measure multiple activation times in case of   multiple stimuli or multiple waves.</li> <li><code>ECGTracker</code>: Measure EGMs and ECGs signals in the tissue.</li> <li><code>ActionPotentialTracker</code>: Measure action potentials in the specific cell   of the tissue.</li> <li><code>VariableTracker</code>: Measure any variable in the specific cell of the tissue.</li> <li><code>AnimationTracker</code>: Create an animation using variable values in the tissue.</li> <li><code>PeriodTracker</code>: Measure the period of the wave in the tissue.</li> </ul>"},{"location":"overview/#visualization","title":"Visualization","text":"<p>Finitewave provides several tools for visualizing the results of cardiac electrophysiology simulations in 3D. To show the results of the simulation, use the <code>VisMeshBuilder3D</code> class to build a 3D mesh from the simulation results and visualize the results using the <code>plot()</code> method. The <code>VisMeshBuilder3D</code> based on <code>pyvista</code> library. The result can be saved as <code>.vtk</code> or <code>.vtu</code> file for further analysis.</p> <pre><code>\n   import finitewave as fw\n\n   # Create a 3D mesh builder\n   mesh_builder = fw.VisMeshBuilder3D()\n\n   # Build a 3D mesh and mask empty (0) nodes\n   grid = mesh_builder.build_mesh(tissue.mesh)\n\n   # Add scalar data to the mesh\n   grid = mesh_builder.add_scalar(aliev_panfilov.u, 'u')\n\n   # Plot the mesh\n   grid.plot(clim=[0, 1], cmap='viridis')\n\n   # Save the potentials\n   grid.save('u.vtk')\n\n</code></pre>"},{"location":"api/ActionPotential2DTracker/","title":"ActionPotential2DTracker","text":"<p>               Bases: <code>Tracker</code></p> <p>A class to track and record the action potential of a specific cell in a 2D cardiac tissue model.</p> <p>This tracker monitors the membrane potential of a single cell at each time step and stores the data in an array for later analysis or visualization.</p> <p>Attributes:</p> Name Type Description <code>act_pot</code> <code>ndarray</code> <p>Array to store the action potential values at each time step.</p> <code>cell_ind</code> <code>list or list of lists with two indices</code> <p>Coordinates of the cell to be tracked in the 2D model grid.</p> <code>file_name</code> <code>str</code> <p>Name of the file where the tracked action potential data will be saved.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the tracker with the simulation model, setting up the action potential array.</p> <code>track</code> <p>Records the action potential of the specified cell at the current time step.</p> <code>output</code> <p>Returns the tracked action potential data.</p> <code>write</code> <p>Saves the tracked action potential data to a file.</p>"},{"location":"api/ActionPotential2DTracker/#finitewave.cpuwave2D.tracker.action_potential_2d_tracker.ActionPotential2DTracker.output","title":"<code>output</code>  <code>property</code>","text":"<p>Returns the tracked action potential data.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The array containing the tracked action potential values.</p>"},{"location":"api/ActionPotential2DTracker/#finitewave.cpuwave2D.tracker.action_potential_2d_tracker.ActionPotential2DTracker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the ActionPotential2DTracker with default parameters.</p>"},{"location":"api/ActionPotential2DTracker/#finitewave.cpuwave2D.tracker.action_potential_2d_tracker.ActionPotential2DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the tracker with the simulation model, setting up the action potential array.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model object that contains simulation parameters like <code>t_max</code> (maximum time) and <code>dt</code> (time step).</p> required"},{"location":"api/ActionPotential3DTracker/","title":"ActionPotential3DTracker","text":"<p>               Bases: <code>Tracker</code></p> <p>A class to track and record the action potential of a specific cell in a 3D cardiac tissue model.</p> <p>This tracker monitors the membrane potential of a single cell at each time step and stores the data in an array for later analysis or visualization.</p> <p>Attributes:</p> Name Type Description <code>act_pot</code> <code>ndarray</code> <p>Array to store the action potential values at each time step.</p> <code>cell_ind</code> <code>list of int</code> <p>Coordinates of the cell to be tracked in the 3D model grid.</p> <code>file_name</code> <code>str</code> <p>Name of the file where the tracked action potential data will be saved.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the tracker with the simulation model, setting up the action potential array.</p> <code>track</code> <p>Records the action potential of the specified cell at the current time step.</p> <code>output</code> <p>Returns the tracked action potential data.</p> <code>write</code> <p>Saves the tracked action potential data to a file.</p>"},{"location":"api/ActionPotential3DTracker/#finitewave.cpuwave3D.tracker.action_potential_3d_tracker.ActionPotential3DTracker.output","title":"<code>output</code>  <code>property</code>","text":"<p>Returns the tracked action potential data.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The array containing the tracked action potential values.</p>"},{"location":"api/ActionPotential3DTracker/#finitewave.cpuwave3D.tracker.action_potential_3d_tracker.ActionPotential3DTracker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the ActionPotential3DTracker with default parameters.</p>"},{"location":"api/ActionPotential3DTracker/#finitewave.cpuwave3D.tracker.action_potential_3d_tracker.ActionPotential3DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the tracker with the simulation model, setting up the action potential array.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model object that contains simulation parameters like <code>t_max</code> (maximum time) and <code>dt</code> (time step).</p> required"},{"location":"api/ActionPotential3DTracker/#finitewave.cpuwave3D.tracker.action_potential_3d_tracker.ActionPotential3DTracker.track","title":"<code>track()</code>","text":"<p>Records the action potential of the specified cell at the current time step.</p> <p>The action potential value is retrieved from the model's <code>u</code> matrix at the coordinates specified by <code>cell_ind</code>.</p>"},{"location":"api/ActionPotential3DTracker/#finitewave.cpuwave3D.tracker.action_potential_3d_tracker.ActionPotential3DTracker.write","title":"<code>write()</code>","text":"<p>Saves the tracked action potential data to a file.</p> <p>The file is saved in the path specified by <code>self.path</code> with the name <code>self.file_name</code>.</p>"},{"location":"api/ActivationTime2DTracker/","title":"ActivationTime2DTracker","text":"<p>               Bases: <code>Tracker</code></p> <p>A class to track and record the activation time of each cell in a 2D cardiac tissue model.</p> <p>This tracker monitors the membrane potential of each cell and records the time at which the potential crosses a certain threshold, indicating cell activation.</p> <p>Attributes:</p> Name Type Description <code>act_t</code> <code>ndarray</code> <p>Array to store the activation time of each cell in the 2D model grid.</p> <code>threshold</code> <code>float</code> <p>The membrane potential threshold value that determines cell activation.</p> <code>file_name</code> <code>str</code> <p>Name of the file where the tracked activation time data will be saved.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the tracker with the simulation model, setting up the activation time array.</p> <code>track</code> <p>Records the activation time of each cell based on the threshold crossing.</p> <code>output</code> <p>Returns the tracked activation time data.</p> <code>write</code> <p>Saves the tracked activation time data to a file.</p>"},{"location":"api/ActivationTime2DTracker/#finitewave.cpuwave2D.tracker.activation_time_2d_tracker.ActivationTime2DTracker.output","title":"<code>output</code>  <code>property</code>","text":"<p>Returns the tracked activation time data.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The array containing the activation time of each cell in the grid.</p>"},{"location":"api/ActivationTime2DTracker/#finitewave.cpuwave2D.tracker.activation_time_2d_tracker.ActivationTime2DTracker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the ActivationTime2DTracker with default parameters.</p>"},{"location":"api/ActivationTime2DTracker/#finitewave.cpuwave2D.tracker.activation_time_2d_tracker.ActivationTime2DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the tracker with the simulation model, setting up the activation time array.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model object that contains the grid (<code>u</code>) of membrane potentials.</p> required"},{"location":"api/ActivationTime3DTracker/","title":"ActivationTime3DTracker","text":"<p>               Bases: <code>Tracker</code></p> <p>A class to track and record the activation time of each cell in a 3D cardiac tissue model.</p> <p>This tracker monitors the membrane potential of each cell and records the time at which the potential crosses a certain threshold, indicating cell activation.</p> <p>Attributes:</p> Name Type Description <code>act_t</code> <code>ndarray</code> <p>Array to store the activation time of each cell in the 3D model grid.</p> <code>threshold</code> <code>float</code> <p>The membrane potential threshold value that determines cell activation.</p> <code>file_name</code> <code>str</code> <p>Name of the file where the tracked activation time data will be saved.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the tracker with the simulation model, setting up the activation time array.</p> <code>track</code> <p>Records the activation time of each cell based on the threshold crossing.</p> <code>output</code> <p>Returns the tracked activation time data.</p> <code>write</code> <p>Saves the tracked activation time data to a file.</p>"},{"location":"api/ActivationTime3DTracker/#finitewave.cpuwave3D.tracker.activation_time_3d_tracker.ActivationTime3DTracker.output","title":"<code>output</code>  <code>property</code>","text":"<p>Returns the tracked activation time data.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The array containing the activation time of each cell in the 3D grid.</p>"},{"location":"api/ActivationTime3DTracker/#finitewave.cpuwave3D.tracker.activation_time_3d_tracker.ActivationTime3DTracker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the ActivationTime3DTracker with default parameters.</p>"},{"location":"api/ActivationTime3DTracker/#finitewave.cpuwave3D.tracker.activation_time_3d_tracker.ActivationTime3DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the tracker with the simulation model, setting up the activation time array.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model object that contains the grid (<code>u</code>) of membrane potentials.</p> required"},{"location":"api/ActivationTime3DTracker/#finitewave.cpuwave3D.tracker.activation_time_3d_tracker.ActivationTime3DTracker.track","title":"<code>track()</code>","text":"<p>Records the activation time of each cell based on the threshold crossing.</p> <p>The activation time is recorded as the first instance where the membrane potential of a cell crosses the threshold value.</p>"},{"location":"api/ActivationTime3DTracker/#finitewave.cpuwave3D.tracker.activation_time_3d_tracker.ActivationTime3DTracker.write","title":"<code>write()</code>","text":"<p>Saves the tracked activation time data to a file.</p> <p>The file is saved in the path specified by <code>self.path</code> with the name <code>self.file_name</code>.</p>"},{"location":"api/AlievPanfilov2D/","title":"AlievPanfilov2D","text":"<p>               Bases: <code>CardiacModel</code></p> <p>Implementation of the Aliev-Panfilov 2D cardiac model.</p> <p>This model simulates the electrical activity in cardiac tissue using the  Aliev-Panfilov equations. It extends the CardiacModel base class and provides methods to initialize the model, run the ionic kernel, and handle simulation state.</p> <p>Attributes:</p> Name Type Description <code>v</code> <code>ndarray</code> <p>Array for the recovery variable.</p> <code>w</code> <code>ndarray</code> <p>Array for diffusion weights.</p> <code>state_vars</code> <code>list</code> <p>List of state variables to be saved and restored.</p> <code>npfloat</code> <code>str</code> <p>Data type used for floating-point operations, default is 'float64'.</p> <code>diffuse_kernel</code> <code>function</code> <p>Function for performing diffusion computations.</p> <code>ionic_kernel</code> <code>function</code> <p>Function for performing ionic computations.</p>"},{"location":"api/AlievPanfilov2D/#finitewave.cpuwave2D.model.aliev_panfilov_2d.aliev_panfilov_2d.AlievPanfilov2D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the AlievPanfilov2D instance with default parameters.</p>"},{"location":"api/AlievPanfilov2D/#finitewave.cpuwave2D.model.aliev_panfilov_2d.aliev_panfilov_2d.AlievPanfilov2D.initialize","title":"<code>initialize()</code>","text":"<p>Initializes the model for simulation.</p> <p>This method sets up the diffusion and ionic kernel functions, initializes arrays for the action potential and recovery variable, and prepares the model  for simulation. It calls the base class initialization method and sets up  the diffusion and ionic kernels specific to the Aliev-Panfilov model.</p>"},{"location":"api/AlievPanfilov2D/#finitewave.cpuwave2D.model.aliev_panfilov_2d.aliev_panfilov_2d.AlievPanfilov2D.run_ionic_kernel","title":"<code>run_ionic_kernel()</code>","text":"<p>Executes the ionic kernel for the Aliev-Panfilov model.</p> <p>This method updates the action potential and recovery variable arrays using the ionic kernel function retrieved during initialization.</p> <p>It applies the Aliev-Panfilov equations to compute the next state of the  action potential and recovery variable based on the current state of the model.</p>"},{"location":"api/AlievPanfilov3D/","title":"AlievPanfilov3D","text":"<p>               Bases: <code>CardiacModel</code></p> <p>Implementation of the Aliev-Panfilov 3D cardiac model.</p> <p>This model simulates the electrical activity in cardiac tissue using the  Aliev-Panfilov equations. It extends the CardiacModel base class and provides methods to initialize the model, run the ionic kernel, and handle simulation state.</p> <p>Attributes:</p> Name Type Description <code>v</code> <code>ndarray</code> <p>Array for the recovery variable.</p> <code>w</code> <code>ndarray</code> <p>Array for diffusion weights.</p> <code>state_vars</code> <code>list</code> <p>List of state variables to be saved and restored.</p> <code>npfloat</code> <code>str</code> <p>Data type used for floating-point operations, default is 'float64'.</p> <code>diffuse_kernel</code> <code>function</code> <p>Function for performing diffusion computations.</p> <code>ionic_kernel</code> <code>function</code> <p>Function for performing ionic computations.</p>"},{"location":"api/AlievPanfilov3D/#finitewave.cpuwave3D.model.aliev_panfilov_3d.aliev_panfilov_3d.AlievPanfilov3D.initialize","title":"<code>initialize()</code>","text":"<p>Initializes the model for simulation.</p> <p>This method sets up the diffusion and ionic kernel functions, initializes arrays for the action potential and recovery variable, and prepares the model  for simulation. It calls the base class initialization method and sets up  the diffusion and ionic kernels specific to the Aliev-Panfilov model.</p>"},{"location":"api/AlievPanfilov3D/#finitewave.cpuwave3D.model.aliev_panfilov_3d.aliev_panfilov_3d.AlievPanfilov3D.run_ionic_kernel","title":"<code>run_ionic_kernel()</code>","text":"<p>Executes the ionic kernel for the Aliev-Panfilov model.</p> <p>This method updates the action potential and recovery variable arrays using the ionic kernel function retrieved during initialization.</p> <p>It applies the Aliev-Panfilov equations to compute the next state of the  action potential and recovery variable based on the current state of the model.</p>"},{"location":"api/AlievPanfilovKernels2D/","title":"AlievPanfilovKernels2D","text":"<p>Provides kernel functions for the Aliev-Panfilov 2D model.</p> <p>This class includes methods for retrieving diffusion and ionic kernels specific to the Aliev-Panfilov 2D model.</p> <p>Methods:</p> Name Description <code>get_diffuse_kernel</code> <p>Returns the appropriate diffusion kernel function based on the shape of weights.</p> <code>get_ionic_kernel</code> <p>Returns the ionic kernel function for the Aliev-Panfilov 2D model.</p>"},{"location":"api/AlievPanfilovKernels2D/#finitewave.cpuwave2D.model.aliev_panfilov_2d.aliev_panfilov_kernels_2d.AlievPanfilovKernels2D.get_diffuse_kernel","title":"<code>get_diffuse_kernel(shape)</code>  <code>staticmethod</code>","text":"<p>Retrieves the diffusion kernel function based on the shape of weights.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple</code> <p>The shape of the weights array used for determining the diffusion kernel.</p> required <p>Returns:</p> Type Description <code>function</code> <p>The appropriate diffusion kernel function.</p> <p>Raises:</p> Type Description <code>IncorrectWeightsShapeError</code> <p>If the shape of the weights array is not recognized.</p>"},{"location":"api/AlievPanfilovKernels2D/#finitewave.cpuwave2D.model.aliev_panfilov_2d.aliev_panfilov_kernels_2d.AlievPanfilovKernels2D.get_ionic_kernel","title":"<code>get_ionic_kernel()</code>  <code>staticmethod</code>","text":"<p>Retrieves the ionic kernel function for the Aliev-Panfilov 2D model.</p> <p>Returns:</p> Type Description <code>function</code> <p>The ionic kernel function.</p>"},{"location":"api/AlievPanfilovKernels3D/","title":"AlievPanfilovKernels3D","text":"<p>Provides kernel functions for the Aliev-Panfilov 3D model.</p> <p>This class includes methods for retrieving diffusion and ionic kernels specific to the Aliev-Panfilov 3D model.</p> <p>Methods:</p> Name Description <code>get_diffuse_kernel</code> <p>Returns the appropriate diffusion kernel function based on the shape of weights.</p> <code>get_ionic_kernel</code> <p>Returns the ionic kernel function for the Aliev-Panfilov 3D model.</p>"},{"location":"api/AlievPanfilovKernels3D/#finitewave.cpuwave3D.model.aliev_panfilov_3d.aliev_panfilov_kernels_3d.AlievPanfilovKernels3D.get_diffuse_kernel","title":"<code>get_diffuse_kernel(shape)</code>  <code>staticmethod</code>","text":"<p>Retrieves the diffusion kernel function based on the shape of weights.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple</code> <p>The shape of the weights array used for determining the diffusion kernel.</p> required <p>Returns:</p> Type Description <code>function</code> <p>The appropriate diffusion kernel function.</p> <p>Raises:</p> Type Description <code>IncorrectWeightsShapeError</code> <p>If the shape of the weights array is not recognized.</p>"},{"location":"api/AlievPanfilovKernels3D/#finitewave.cpuwave3D.model.aliev_panfilov_3d.aliev_panfilov_kernels_3d.AlievPanfilovKernels3D.get_ionic_kernel","title":"<code>get_ionic_kernel()</code>  <code>staticmethod</code>","text":"<p>Retrieves the ionic kernel function for the Aliev-Panfilov 3D model.</p> <p>Returns:</p> Type Description <code>function</code> <p>The ionic kernel function.</p>"},{"location":"api/Animation2DTracker/","title":"Animation2DTracker","text":"<p>               Bases: <code>Tracker</code></p> <p>A class to track and save frames of a 2D cardiac tissue model simulation for animation purposes.</p> <p>This tracker periodically saves the state of a specified target array from the model to disk as NumPy files, which can later be used to create animations.</p> <p>Attributes:</p> Name Type Description <code>step</code> <code>int</code> <p>Interval in time steps at which frames are saved.</p> <code>start</code> <code>float</code> <p>The time at which to start recording frames.</p> <code>_t</code> <code>float</code> <p>Internal counter for keeping track of the elapsed time since the last frame was saved.</p> <code>dir_name</code> <code>str</code> <p>Directory name where animation frames are stored.</p> <code>_frame_n</code> <code>int</code> <p>Internal counter to keep track of the number of frames saved.</p> <code>target_array</code> <code>str</code> <p>The name of the model attribute to be saved as a frame.</p> <code>frame_format</code> <code>dict</code> <p>A dictionary defining the format of saved frames. Contains 'type' (data type) and 'mult' (multiplier for scaling).</p> <code>_frame_format_type</code> <code>str</code> <p>Internal storage for the data type of the saved frames.</p> <code>_frame_format_mult</code> <code>float</code> <p>Internal storage for the multiplier for scaling the saved frames.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the tracker with the simulation model and sets up directories for saving frames.</p> <code>track</code> <p>Saves frames based on the specified step interval and target array.</p> <code>write</code> <p>No operation. Exists to fulfill the interface requirements.</p>"},{"location":"api/Animation2DTracker/#finitewave.cpuwave2D.tracker.animation_2d_tracker.Animation2DTracker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Animation2DTracker with default parameters.</p>"},{"location":"api/Animation2DTracker/#finitewave.cpuwave2D.tracker.animation_2d_tracker.Animation2DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the tracker with the simulation model and sets up directories for saving frames.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model object containing the data to be tracked.</p> required"},{"location":"api/Animation2DTracker/#finitewave.cpuwave2D.tracker.animation_2d_tracker.Animation2DTracker.track","title":"<code>track()</code>","text":"<p>Saves frames based on the specified step interval and target array.</p> <p>The frames are saved in the specified directory as NumPy files.</p>"},{"location":"api/Animation2DTracker/#finitewave.cpuwave2D.tracker.animation_2d_tracker.Animation2DTracker.write","title":"<code>write()</code>","text":"<p>No operation for this tracker. Exists to fulfill the interface requirements.</p>"},{"location":"api/Animation3DBuilder/","title":"Animation3DBuilder","text":""},{"location":"api/Animation3DBuilder/#finitewave.tools.animation_3d_builder.Animation3DBuilder.load_scalar","title":"<code>load_scalar(path, mask=None)</code>","text":"<p>Load the scalar field from a file.</p> <p>Args:     path (str): Path to the snapshot folder.     mask (np.array, optional): Mask to apply to the scalar field.</p> <p>Returns:     np.array: Scalar field.</p>"},{"location":"api/Animation3DBuilder/#finitewave.tools.animation_3d_builder.Animation3DBuilder.write","title":"<code>write(path, mask=None, path_save=None, window_size=(800, 800), clim=[0, 1], scalar_name='Scalar', animation_name='animation', cmap='viridis', scalar_bar=False, format='mp4', **kwargs)</code>","text":"<p>Write the animation to a file.</p> <p>Args:     path (str): Path to the snapshot folder.     mask (np.array, optional): Mask to apply to the scalar field.         Defaults to None.     path_save (str, optional): Path to save the animation.         Defaults is parent directory of path.     window_size (tuple, optional): Size of the window.         Defaults to (800, 800).     clim (list, optional): Color limits. Defaults to [0, 1].     scalar_name (str, optional): Name of the scalar field.         Defaults to \"Scalar\".     cmap (str, optional): Color map. Defaults to \"viridis\".     scalar_bar (bool, optional): Show scalar bar. Defaults to False.     format (str, optional): Format of the animation. Defaults to \"mp4\".         Other options are \"gif\".</p>"},{"location":"api/Animation3DTracker/","title":"Animation3DTracker","text":"<p>               Bases: <code>Tracker</code></p> <p>A class to track and save frames of a 3D cardiac tissue model simulation for animation purposes.</p> <p>This tracker periodically saves the state of a specified target array from the model to disk as NumPy files, which can later be used to create animations.</p> <p>Attributes:</p> Name Type Description <code>step</code> <code>int</code> <p>Interval in time steps at which frames are saved.</p> <code>start</code> <code>float</code> <p>The time at which to start recording frames.</p> <code>_t</code> <code>float</code> <p>Internal counter for keeping track of the elapsed time since the last frame was saved.</p> <code>dir_name</code> <code>str</code> <p>Directory name where animation frames are stored.</p> <code>_frame_n</code> <code>int</code> <p>Internal counter to keep track of the number of frames saved.</p> <code>target_array</code> <code>str</code> <p>The name of the model attribute to be saved as a frame.</p> <code>frame_format</code> <code>dict</code> <p>A dictionary defining the format of saved frames. Contains 'type' (data type) and 'mult' (multiplier for scaling).</p> <code>_frame_format_type</code> <code>str</code> <p>Internal storage for the data type of the saved frames.</p> <code>_frame_format_mult</code> <code>float</code> <p>Internal storage for the multiplier for scaling the saved frames.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the tracker with the simulation model and sets up directories for saving frames.</p> <code>track</code> <p>Saves frames based on the specified step interval and target array.</p> <code>write</code> <p>No operation. Exists to fulfill the interface requirements.</p>"},{"location":"api/Animation3DTracker/#finitewave.cpuwave3D.tracker.animation_3d_tracker.Animation3DTracker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Animation3DTracker with default parameters.</p>"},{"location":"api/Animation3DTracker/#finitewave.cpuwave3D.tracker.animation_3d_tracker.Animation3DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the tracker with the simulation model and sets up directories for saving frames.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model object containing the data to be tracked.</p> required"},{"location":"api/Animation3DTracker/#finitewave.cpuwave3D.tracker.animation_3d_tracker.Animation3DTracker.track","title":"<code>track()</code>","text":"<p>Saves frames based on the specified step interval and target array.</p> <p>The frames are saved in the specified directory as NumPy files.</p>"},{"location":"api/Animation3DTracker/#finitewave.cpuwave3D.tracker.animation_3d_tracker.Animation3DTracker.write","title":"<code>write(path=None, clim=[0, 1], cmap='viridis', scalar_bar=False, format='mp4', clear=False, **kwargs)</code>","text":"<p>Write the animation to a file.</p> <p>Args:     path (str, optional): Path to save the animation.         Defaults is path of the tracker.     clim (list, optional): Color limits. Defaults to [0, 1].     cmap (str, optional): Color map. Defaults to \"viridis\".     scalar_bar (bool, optional): Show scalar bar. Defaults to False.     format (str, optional): Format of the animation. Defaults to \"mp4\".         Other options are \"gif\".     clear (bool, optional): Clear the snapshot folder after writing         the animation. Defaults to False.     **kwargs: Additional arguments for the animation writer.</p>"},{"location":"api/AnimationBuilder/","title":"AnimationBuilder","text":""},{"location":"api/AnimationSlice3DTracker/","title":"AnimationSlice3DTracker","text":"<p>               Bases: <code>Tracker</code></p>"},{"location":"api/AsymmetricStencil2D/","title":"AsymmetricStencil2D","text":"<p>               Bases: <code>Stencil</code></p> <p>A class to represent a 2D asymmetric stencil for diffusion processes.</p> Inherits from: <p>Stencil     Base class for different stencils used in diffusion calculations.</p> <p>Methods:</p> Name Description <code>get_weights</code> <p>Computes the weights for diffusion based on the asymmetric stencil.</p>"},{"location":"api/AsymmetricStencil2D/#finitewave.cpuwave2D.stencil.asymmetric_stencil_2d.AsymmetricStencil2D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the AsymmetricStencil2D with default settings.</p>"},{"location":"api/AsymmetricStencil2D/#finitewave.cpuwave2D.stencil.asymmetric_stencil_2d.AsymmetricStencil2D.get_weights","title":"<code>get_weights(mesh, conductivity, fibers, D_al, D_ac, dt, dr)</code>","text":"<p>Computes the weights for diffusion on a 2D mesh using an asymmetric stencil.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>ndarray</code> <p>2D array representing the mesh grid of the tissue. Non-tissue areas are set to 0.</p> required <code>conductivity</code> <code>float</code> <p>Conductivity of the tissue, which scales the diffusion coefficient.</p> required <code>fibers</code> <code>ndarray</code> <p>Array representing fiber orientations. Used to compute directional diffusion coefficients.</p> required <code>D_al</code> <code>float</code> <p>Longitudinal diffusion coefficient.</p> required <code>D_ac</code> <code>float</code> <p>Cross-sectional diffusion coefficient.</p> required <code>dt</code> <code>float</code> <p>Temporal resolution.</p> required <code>dr</code> <code>float</code> <p>Spatial resolution.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3D array of weights for diffusion, with the shape of (mesh.shape[0], mesh.shape[1], 9).</p> Notes <p>The method assumes asymmetric diffusion where different coefficients are used for different directions. The weights are computed for eight surrounding directions and the central weight, based on the asymmetric stencil. Heterogeneity in the diffusion coefficients is handled by adjusting the weights based on fiber orientations.</p>"},{"location":"api/AsymmetricStencil3D/","title":"AsymmetricStencil3D","text":"<p>               Bases: <code>Stencil</code></p> <p>A class to represent a 3D asymmetric stencil for diffusion processes.</p> Inherits from: <p>Stencil     Base class for different stencils used in diffusion calculations.</p> <p>Methods:</p> Name Description <code>get_weights</code> <p>Computes the weights for diffusion based on the asymmetric stencil.</p>"},{"location":"api/AsymmetricStencil3D/#finitewave.cpuwave3D.stencil.asymmetric_stencil_3d.AsymmetricStencil3D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the AsymmetricStencil3D with default settings.</p>"},{"location":"api/AsymmetricStencil3D/#finitewave.cpuwave3D.stencil.asymmetric_stencil_3d.AsymmetricStencil3D.get_weights","title":"<code>get_weights(mesh, conductivity, fibers, D_al, D_ac, dt, dr)</code>","text":"<p>Computes the weights for diffusion on a 3D mesh using an asymmetric stencil.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>ndarray</code> <p>3D array representing the mesh grid of the tissue. Non-tissue areas are set to 0.</p> required <code>conductivity</code> <code>float</code> <p>Conductivity of the tissue, which scales the diffusion coefficient.</p> required <code>fibers</code> <code>ndarray</code> <p>Array representing fiber orientations. Used to compute directional diffusion coefficients.</p> required <code>D_al</code> <code>float</code> <p>Longitudinal diffusion coefficient.</p> required <code>D_ac</code> <code>float</code> <p>Cross-sectional diffusion coefficient.</p> required <code>dt</code> <code>float</code> <p>Temporal resolution.</p> required <code>dr</code> <code>float</code> <p>Spatial resolution.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>4D array of weights for diffusion, with the shape of (mesh.shape[0], mesh.shape[1], 9).</p> Notes <p>The method assumes asymmetric diffusion where different coefficients are used for different directions. The weights are computed for eight surrounding directions and the central weight, based on the asymmetric stencil. Heterogeneity in the diffusion coefficients is handled by adjusting the weights based on fiber orientations.</p>"},{"location":"api/CardiacModel/","title":"CardiacModel","text":"<p>Base class for electrophysiological models.</p> <p>This class serves as the base for implementing various cardiac models. It provides methods for initializing the model, running simulations, and managing the state of the simulation.</p> <p>Attributes:</p> Name Type Description <code>cardiac_tissue</code> <code>CardiacTissue</code> <p>The tissue object that represents the cardiac tissue in the simulation.</p> <code>stim_sequence</code> <code>StimSequence</code> <p>The sequence of stimuli applied to the cardiac tissue.</p> <code>tracker_sequence</code> <code>TrackerSequence</code> <p>The sequence of trackers used to monitor the simulation.</p> <code>command_sequence</code> <code>CommandSequence</code> <p>The sequence of commands to execute during the simulation.</p> <code>state_keeper</code> <code>StateKeeper</code> <p>The object responsible for saving and loading the state of the simulation.</p> <code>stencil</code> <code>Stencil</code> <p>The stencil used for numerical computations.</p> <code>u</code> <code>ndarray</code> <p>Array representing the action potential (mV) across the tissue.</p> <code>u_new</code> <code>ndarray</code> <p>Array for storing the updated action potential values.</p> <code>dt</code> <code>float</code> <p>Time step for the simulation.</p> <code>dr</code> <code>float</code> <p>Spatial step for the simulation.</p> <code>t_max</code> <code>float</code> <p>Maximum time for the simulation (model units).</p> <code>t</code> <code>float</code> <p>Current time in the simulation (model units).</p> <code>step</code> <code>int</code> <p>Current step or iteration in the simulation.</p> <code>prog_bar</code> <code>bool</code> <p>Flag to enable or disable the progress bar during simulation.</p> <code>state_vars</code> <code>list</code> <p>List of state variables to be saved and restored.</p> <p>Methods:</p> Name Description <code>run_ionic_kernel</code> <p>Abstract method to be implemented by subclasses for running the ionic kernel.</p> <code>diffuse_kernel</code> <p>Abstract method to be implemented by subclasses for diffusion computation.</p> <code>save_state</code> <p>Abstract method to be implemented by subclasses for saving the simulation state.</p> <code>load_state</code> <p>Abstract method to be implemented by subclasses for loading the simulation state.</p> <code>initialize</code> <p>Initializes the model for simulation, setting up arrays and computing weights.</p> <code>run</code> <p>Runs the simulation loop, handling stimuli, diffusion, ionic kernel updates, and tracking.</p> <code>run_diffuse_kernel</code> <p>Runs the diffusion kernel computation.</p> <code>clone</code> <p>Creates a deep copy of the current model instance.</p>"},{"location":"api/CardiacModel/#finitewave.core.model.cardiac_model.CardiacModel.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the CardiacModel instance with default parameters and attributes.</p>"},{"location":"api/CardiacModel/#finitewave.core.model.cardiac_model.CardiacModel.clone","title":"<code>clone()</code>","text":"<p>Creates a deep copy of the current model instance.</p> <p>Returns:</p> Type Description <code>CardiacModel</code> <p>A deep copy of the current CardiacModel instance.</p>"},{"location":"api/CardiacModel/#finitewave.core.model.cardiac_model.CardiacModel.diffuse_kernel","title":"<code>diffuse_kernel(u_new, u, w, mesh)</code>  <code>abstractmethod</code>","text":"<p>Abstract method for diffusion computation. Must be implemented by subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>u_new</code> <code>ndarray</code> <p>The array to store updated action potential values.</p> required <code>u</code> <code>ndarray</code> <p>The current action potential array.</p> required <code>w</code> <code>ndarray</code> <p>The weights for the diffusion computation.</p> required <code>mesh</code> <code>ndarray</code> <p>The tissue mesh.</p> required"},{"location":"api/CardiacModel/#finitewave.core.model.cardiac_model.CardiacModel.initialize","title":"<code>initialize()</code>","text":"<p>Initializes the model for simulation. Sets up arrays, computes weights, and initializes stimuli, trackers, and commands.</p>"},{"location":"api/CardiacModel/#finitewave.core.model.cardiac_model.CardiacModel.load_state","title":"<code>load_state(path)</code>  <code>abstractmethod</code>","text":"<p>Abstract method for loading the simulation state. Must be implemented by subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The directory path from where the state will be loaded.</p> required"},{"location":"api/CardiacModel/#finitewave.core.model.cardiac_model.CardiacModel.run","title":"<code>run(initialize=True)</code>","text":"<p>Runs the simulation loop. Handles stimuli, diffusion, ionic kernel updates, and tracking.</p> <p>Parameters:</p> Name Type Description Default <code>initialize</code> <code>bool</code> <p>Whether to (re)initialize the model before running the simulation. Default is True.</p> <code>True</code>"},{"location":"api/CardiacModel/#finitewave.core.model.cardiac_model.CardiacModel.run_diffuse_kernel","title":"<code>run_diffuse_kernel()</code>","text":"<p>Executes the diffusion kernel computation using the current parameters and tissue weights.</p>"},{"location":"api/CardiacModel/#finitewave.core.model.cardiac_model.CardiacModel.run_ionic_kernel","title":"<code>run_ionic_kernel()</code>  <code>abstractmethod</code>","text":"<p>Abstract method for running the ionic kernel. Must be implemented by subclasses.</p>"},{"location":"api/CardiacModel/#finitewave.core.model.cardiac_model.CardiacModel.save_state","title":"<code>save_state(path)</code>  <code>abstractmethod</code>","text":"<p>Abstract method for saving the simulation state. Must be implemented by subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The directory path where the state will be saved.</p> required"},{"location":"api/CardiacTissue/","title":"CardiacTissue","text":"<p>Base class for a model tissue.</p> <p>This class represents the tissue model used in cardiac simulations. It includes attributes and methods for defining the tissue structure, its properties, and handling fibrosis patterns.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>ndarray</code> <p>A 2D or 3D array of integers representing the tissue grid, where: - <code>0</code> denotes empty points (non-cardiac tissue). - <code>1</code> denotes cardiomyocytes (healthy cardiac tissue). - <code>2</code> denotes fibrosis (damaged or non-conductive tissue).</p> <code>conductivity</code> <code>numpy.ndarray or float, default: 1.0</code> <p>A 2D or 3D array of floats in the range [0, 1], representing the conductivity of the tissue.  Conductivity values are multiplied with diffusion coefficients to model varying conductance in fibrosis areas.</p> <code>fibers</code> <code>ndarray</code> <p>A 2D or 3D array where each node contains a 2D or 3D vector specifying the direction of the fibers at that location.</p> <code>D_al</code> <code>float</code> <p>Diffusion coefficient along the fiber direction. This determines the rate of diffusion parallel to the fibers.</p> <code>D_ac</code> <code>float</code> <p>Diffusion coefficient across the fiber direction. This determines the rate of diffusion perpendicular to the fibers.</p> <code>weights</code> <code>ndarray</code> <p>A 2D or 3D array of weights computed based on the tissue mesh, including cardiomyocytes, empty nodes, and fibrosis nodes.</p> <code>shape</code> <code>list or tuple</code> <p>The shape of the mesh as a list or tuple, e.g., <code>[ni, nj]</code> for 2D or <code>[ni, nj, nk]</code> for 3D.</p> <code>meta</code> <code>dict</code> <p>A dictionary to store additional metadata about the tissue.</p> <p>Methods:</p> Name Description <code>add_boundaries</code> <p>Abstract method to be implemented by subclasses for adding boundary conditions to the tissue mesh.</p> <code>compute_weights</code> <p>Abstract method to be implemented by subclasses for computing weights based on the tissue properties and structure.</p> <code>add_pattern</code> <p>Applies a fibrosis pattern to the tissue mesh.</p> <code>clean</code> <p>Removes all fibrosis points from the mesh, setting them to <code>1</code> (healthy tissue).</p> <code>clone</code> <p>Creates a deep copy of the current <code>CardiacTissue</code> instance.</p> <code>set_dtype</code> <p>Sets the data type for the <code>weights</code> and <code>mesh</code> arrays.</p>"},{"location":"api/CardiacTissue/#finitewave.core.tissue.cardiac_tissue.CardiacTissue.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the CardiacTissue instance with default attributes.</p>"},{"location":"api/CardiacTissue/#finitewave.core.tissue.cardiac_tissue.CardiacTissue.add_boundaries","title":"<code>add_boundaries()</code>  <code>abstractmethod</code>","text":"<p>Abstract method to be implemented by subclasses for adding boundary conditions to the tissue mesh.</p>"},{"location":"api/CardiacTissue/#finitewave.core.tissue.cardiac_tissue.CardiacTissue.add_pattern","title":"<code>add_pattern(fibro_pattern)</code>","text":"<p>Applies a fibrosis pattern to the tissue mesh.</p> <p>Parameters:</p> Name Type Description Default <code>fibro_pattern</code> <code>FibrosisPattern</code> <p>An instance of a <code>FibrosisPattern</code> class that defines the pattern of fibrosis to be applied.</p> required"},{"location":"api/CardiacTissue/#finitewave.core.tissue.cardiac_tissue.CardiacTissue.clean","title":"<code>clean()</code>","text":"<p>Removes all fibrosis points from the mesh, setting them to <code>1</code> (healthy tissue).</p>"},{"location":"api/CardiacTissue/#finitewave.core.tissue.cardiac_tissue.CardiacTissue.clone","title":"<code>clone()</code>","text":"<p>Creates a deep copy of the current <code>CardiacTissue</code> instance.</p> <p>Returns:</p> Type Description <code>CardiacTissue</code> <p>A deep copy of the current <code>CardiacTissue</code> instance.</p>"},{"location":"api/CardiacTissue/#finitewave.core.tissue.cardiac_tissue.CardiacTissue.compute_weights","title":"<code>compute_weights()</code>  <code>abstractmethod</code>","text":"<p>Abstract method to be implemented by subclasses for computing weights based on the tissue properties and structure.</p>"},{"location":"api/CardiacTissue/#finitewave.core.tissue.cardiac_tissue.CardiacTissue.set_dtype","title":"<code>set_dtype(dtype)</code>","text":"<p>Sets the data type for the <code>weights</code> and <code>mesh</code> arrays.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>type</code> <p>The data type to which the <code>weights</code> and <code>mesh</code> arrays will be cast.</p> required"},{"location":"api/CardiacTissue2D/","title":"CardiacTissue2D","text":"<p>               Bases: <code>CardiacTissue</code></p> <p>A class to represent a 2D cardiac tissue model with isotropic or anisotropic properties.</p> Inherits from: <p>CardiacTissue     Base class for cardiac tissue models.</p> <p>Attributes:</p> Name Type Description <code>shape</code> <code>tuple of int</code> <p>Shape of the 2D grid for the cardiac tissue.</p> <code>mesh</code> <code>ndarray</code> <p>Grid representing the tissue, with boundaries set to zero.</p> <code>stencil</code> <code>IsotropicStencil2D</code> <p>Stencil for calculating weights in the 2D grid.</p> <code>conductivity</code> <code>float</code> <p>Conductivity value for the tissue.</p> <code>fibers</code> <code>ndarray or None</code> <p>Array representing fiber orientations. If None, isotropic weights are used.</p> <code>meta</code> <code>dict</code> <p>Metadata about the tissue, including dimensionality.</p> <code>weights</code> <code>ndarray</code> <p>Weights used for diffusion calculations.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the 2D cardiac tissue model with the given shape and mode.</p> <code>add_boundaries</code> <p>Sets boundary values in the mesh to zero.</p> <code>compute_weights</code> <p>Computes the weights for diffusion based on the stencil and mode.</p>"},{"location":"api/CardiacTissue2D/#finitewave.cpuwave2D.tissue.cardiac_tissue_2d.CardiacTissue2D.__init__","title":"<code>__init__(shape)</code>","text":"<p>Initializes the CardiacTissue2D model.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple of int</code> <p>Shape of the 2D grid for the cardiac tissue.</p> required"},{"location":"api/CardiacTissue2D/#finitewave.cpuwave2D.tissue.cardiac_tissue_2d.CardiacTissue2D.add_boundaries","title":"<code>add_boundaries()</code>","text":"<p>Sets the boundary values of the mesh to zero.</p> <p>The boundaries are defined as the edges of the grid, and this method updates these edges in the mesh array.</p>"},{"location":"api/CardiacTissue2D/#finitewave.cpuwave2D.tissue.cardiac_tissue_2d.CardiacTissue2D.compute_weights","title":"<code>compute_weights(dr, dt)</code>","text":"<p>Computes the weights for diffusion using the stencil and given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>dr</code> <code>float</code> <p>Spatial resolution.</p> required <code>dt</code> <code>float</code> <p>Temporal resolution.</p> required"},{"location":"api/CardiacTissue3D/","title":"CardiacTissue3D","text":"<p>               Bases: <code>CardiacTissue</code></p> <p>A class to represent a 3D cardiac tissue model with isotropic or anisotropic properties.</p> Inherits from: <p>CardiacTissue     Base class for cardiac tissue models.</p> <p>Attributes:</p> Name Type Description <code>shape</code> <code>tuple of int</code> <p>Shape of the 3D grid for the cardiac tissue.</p> <code>mesh</code> <code>ndarray</code> <p>Grid representing the tissue, with boundaries set to zero.</p> <code>stencil</code> <code>IsotropicStencil3D</code> <p>Stencil for calculating weights in the 3D grid.</p> <code>conductivity</code> <code>float</code> <p>Conductivity value for the tissue.</p> <code>fibers</code> <code>ndarray or None</code> <p>Array representing fiber orientations. If None, isotropic weights are used.</p> <code>meta</code> <code>dict</code> <p>Metadata about the tissue, including dimensionality.</p> <code>weights</code> <code>ndarray</code> <p>Weights used for diffusion calculations.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the 3D cardiac tissue model with the given shape and mode.</p> <code>add_boundaries</code> <p>Sets boundary values in the mesh to zero.</p> <code>compute_weights</code> <p>Computes the weights for diffusion based on the stencil and mode.</p>"},{"location":"api/CardiacTissue3D/#finitewave.cpuwave3D.tissue.cardiac_tissue_3d.CardiacTissue3D.__init__","title":"<code>__init__(shape)</code>","text":"<p>Initializes the CardiacTissue3D model.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple of int</code> <p>Shape of the 3D grid for the cardiac tissue.</p> required"},{"location":"api/CardiacTissue3D/#finitewave.cpuwave3D.tissue.cardiac_tissue_3d.CardiacTissue3D.add_boundaries","title":"<code>add_boundaries()</code>","text":"<p>Sets the boundary values of the mesh to zero.</p> <p>The boundaries are defined as the edges of the grid, and this method updates these edges in the mesh array.</p>"},{"location":"api/CardiacTissue3D/#finitewave.cpuwave3D.tissue.cardiac_tissue_3d.CardiacTissue3D.compute_weights","title":"<code>compute_weights(dr, dt)</code>","text":"<p>Computes the weights for diffusion using the stencil and given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>dr</code> <code>float</code> <p>Spatial resolution.</p> required <code>dt</code> <code>float</code> <p>Temporal resolution.</p> required"},{"location":"api/Command/","title":"Command","text":"<p>Base class for a command to be executed during a simulation.</p> <p>Attributes:</p> Name Type Description <code>t</code> <code>float</code> <p>The time at which the command should be executed.</p> <code>passed</code> <code>bool</code> <p>Flag indicating whether the command has been executed.</p> <p>Methods:</p> Name Description <code>execute</code> <p>Abstract method to be implemented by subclasses for executing the command.</p>"},{"location":"api/Command/#finitewave.core.command.command.Command.__init__","title":"<code>__init__(time)</code>","text":"<p>Initializes a Command instance with the specified execution time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the command should be executed.</p> required"},{"location":"api/Command/#finitewave.core.command.command.Command.execute","title":"<code>execute(model)</code>","text":"<p>Abstract method for executing the command. This method should be implemented by subclasses to define the specific behavior of the command.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>CardiacModel</code> <p>The cardiac model instance on which the command will be executed.</p> required"},{"location":"api/CommandSequence/","title":"CommandSequence","text":"<p>Manages a sequence of commands to be executed during a simulation.</p> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>list</code> <p>A list of <code>Command</code> instances representing the sequence of commands to be executed.</p> <code>model</code> <code>CardiacModel</code> <p>The cardiac model instance on which commands will be executed.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the sequence with the specified model and marks all commands as not passed.</p> <code>add_command</code> <p>Adds a <code>Command</code> instance to the sequence.</p> <code>remove_commands</code> <p>Clears the sequence of all commands.</p> <code>execute_next</code> <p>Executes commands whose time has arrived and which have not been executed yet.</p>"},{"location":"api/CommandSequence/#finitewave.core.command.command_sequence.CommandSequence.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a CommandSequence instance with an empty sequence and no model.</p>"},{"location":"api/CommandSequence/#finitewave.core.command.command_sequence.CommandSequence.add_command","title":"<code>add_command(command)</code>","text":"<p>Adds a <code>Command</code> instance to the sequence.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>Command</code> <p>The command instance to be added to the sequence.</p> required"},{"location":"api/CommandSequence/#finitewave.core.command.command_sequence.CommandSequence.execute_next","title":"<code>execute_next()</code>","text":"<p>Executes commands whose time has arrived and which have not been executed yet.</p>"},{"location":"api/CommandSequence/#finitewave.core.command.command_sequence.CommandSequence.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the CommandSequence with the specified model and resets the execution status of all commands.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>CardiacModel</code> <p>The cardiac model instance to be used for command execution.</p> required"},{"location":"api/CommandSequence/#finitewave.core.command.command_sequence.CommandSequence.remove_commands","title":"<code>remove_commands()</code>","text":"<p>Clears the sequence of all commands.</p>"},{"location":"api/Diffuse2DPattern/","title":"Diffuse2DPattern","text":"<p>               Bases: <code>FibrosisPattern</code></p> <p>Class for generating a diffuse 2D fibrosis pattern in a given mesh area.</p> <p>Attributes:</p> Name Type Description <code>x1</code> <code>int</code> <p>The starting x-coordinate of the fibrosis area.</p> <code>x2</code> <code>int</code> <p>The ending x-coordinate of the fibrosis area.</p> <code>y1</code> <code>int</code> <p>The starting y-coordinate of the fibrosis area.</p> <code>y2</code> <code>int</code> <p>The ending y-coordinate of the fibrosis area.</p> <code>dens</code> <code>float</code> <p>The density of the fibrosis, where a value between 0 and 1 represents the probability  of fibrosis in each cell of the specified area.</p> <p>Methods:</p> Name Description <code>generate</code> <p>Generates the fibrosis pattern and updates the provided mesh. If no mesh is provided,  a new mesh is created with the given size.</p>"},{"location":"api/Diffuse2DPattern/#finitewave.cpuwave2D.fibrosis.diffuse_2d_pattern.Diffuse2DPattern.__init__","title":"<code>__init__(x1, x2, y1, y2, dens)</code>","text":"<p>Initializes the Diffuse2DPattern with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>int</code> <p>The starting x-coordinate of the fibrosis area.</p> required <code>x2</code> <code>int</code> <p>The ending x-coordinate of the fibrosis area.</p> required <code>y1</code> <code>int</code> <p>The starting y-coordinate of the fibrosis area.</p> required <code>y2</code> <code>int</code> <p>The ending y-coordinate of the fibrosis area.</p> required <code>dens</code> <code>float</code> <p>The density of the fibrosis, where a value between 0 and 1 represents the probability  of fibrosis in each cell of the specified area.</p> required"},{"location":"api/Diffuse2DPattern/#finitewave.cpuwave2D.fibrosis.diffuse_2d_pattern.Diffuse2DPattern.generate","title":"<code>generate(size, mesh=None)</code>","text":"<p>Generates and applies the diffuse fibrosis pattern to the mesh.</p> <p>If no mesh is provided, a new mesh of zeros with the given size is created. The method  fills the specified area of the mesh with fibrosis based on the defined density.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>tuple of int</code> <p>The size of the mesh to create if no mesh is provided.</p> required <code>mesh</code> <code>ndarray</code> <p>The mesh to which the fibrosis pattern is applied. If None, a new mesh is created  with the given size.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The mesh with the applied diffuse fibrosis pattern.</p>"},{"location":"api/Diffuse3DPattern/","title":"Diffuse3DPattern","text":"<p>               Bases: <code>FibrosisPattern</code></p> <p>A class to generate a diffuse fibrosis pattern in a 3D mesh grid.</p> <p>Attributes:</p> Name Type Description <code>x1, x2</code> <code>int</code> <p>The start and end indices for the region of interest along the x-axis.</p> <code>y1, y2</code> <code>int</code> <p>The start and end indices for the region of interest along the y-axis.</p> <code>z1, z2</code> <code>int</code> <p>The start and end indices for the region of interest along the z-axis.</p> <code>dens</code> <code>float</code> <p>The density of fibrosis within the specified region, ranging from 0 (no fibrosis) to 1 (full fibrosis).</p> <p>Methods:</p> Name Description <code>generate</code> <p>Generates a 3D mesh with a diffuse fibrosis pattern within the specified region.</p>"},{"location":"api/Diffuse3DPattern/#finitewave.cpuwave3D.fibrosis.diffuse_3d_pattern.Diffuse3DPattern.__init__","title":"<code>__init__(x1, x2, y1, y2, z1, z2, dens)</code>","text":"<p>Initializes the Diffuse3DPattern object with the given region of interest and density.</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>int</code> <p>The start and end indices for the region of interest along the x-axis.</p> required <code>x2</code> <code>int</code> <p>The start and end indices for the region of interest along the x-axis.</p> required <code>y1</code> <code>int</code> <p>The start and end indices for the region of interest along the y-axis.</p> required <code>y2</code> <code>int</code> <p>The start and end indices for the region of interest along the y-axis.</p> required <code>z1</code> <code>int</code> <p>The start and end indices for the region of interest along the z-axis.</p> required <code>z2</code> <code>int</code> <p>The start and end indices for the region of interest along the z-axis.</p> required <code>dens</code> <code>float</code> <p>The density of fibrosis within the specified region.</p> required"},{"location":"api/Diffuse3DPattern/#finitewave.cpuwave3D.fibrosis.diffuse_3d_pattern.Diffuse3DPattern.generate","title":"<code>generate(size, mesh=None)</code>","text":"<p>Generates a 3D mesh with a diffuse fibrosis pattern within the specified region.</p> <p>If a mesh is provided, the pattern is applied to the existing mesh; otherwise, a new mesh is created.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>tuple of int</code> <p>The size of the 3D mesh grid (x, y, z).</p> required <code>mesh</code> <code>ndarray</code> <p>A 3D NumPy array representing the existing mesh grid to which the fibrosis pattern will be applied. If None, a new mesh grid of the given size is created.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A 3D NumPy array of the same size as the input, with the diffuse fibrosis pattern applied.</p>"},{"location":"api/DriftVelocityCalculation/","title":"DriftVelocityCalculation","text":""},{"location":"api/ECG2DTracker/","title":"ECG2DTracker","text":"<p>               Bases: <code>Tracker</code></p> <p>A class to compute and track electrocardiogram (ECG) signals from a 2D cardiac tissue model simulation.</p> <p>This tracker calculates ECG signals at specified measurement points by computing the potential differences across the cardiac tissue mesh and considering the inverse square of the distance from each measurement point.</p> <p>Attributes:</p> Name Type Description <code>measure_points</code> <code>ndarray</code> <p>An array of points (x, y, z) where ECG signals are measured.</p> <code>ecg</code> <code>ndarray</code> <p>The computed ECG signals.</p> <code>step</code> <code>int</code> <p>Interval in time steps at which ECG signals are calculated.</p> <code>_index</code> <code>int</code> <p>Internal counter to keep track of the current step index for saving ECG signals.</p> <code>tissue_points</code> <code>tuple</code> <p>Indices of the tissue points in the cardiac mesh where the potential is measured.</p> <code>distances</code> <code>ndarray</code> <p>Precomputed squared distances between measurement points and tissue points.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the tracker with the simulation model and precomputes necessary values.</p> <code>calc_ecg</code> <p>Calculates the ECG signal based on the current potential difference in the model.</p> <code>track</code> <p>Tracks and stores ECG signals at the specified intervals.</p> <code>write</code> <p>Saves the computed ECG signals to disk as a NumPy file.</p>"},{"location":"api/ECG2DTracker/#finitewave.cpuwave2D.tracker.ecg_2d_tracker.ECG2DTracker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the ECG2DTracker with default parameters.</p>"},{"location":"api/ECG2DTracker/#finitewave.cpuwave2D.tracker.ecg_2d_tracker.ECG2DTracker.calc_ecg","title":"<code>calc_ecg()</code>","text":"<p>Calculates the ECG signal based on the current potential difference in the model.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The calculated ECG signals for each measurement point.</p>"},{"location":"api/ECG2DTracker/#finitewave.cpuwave2D.tracker.ecg_2d_tracker.ECG2DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the tracker with the simulation model and precomputes necessary values.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model object containing the data to be tracked.</p> required"},{"location":"api/ECG2DTracker/#finitewave.cpuwave2D.tracker.ecg_2d_tracker.ECG2DTracker.track","title":"<code>track()</code>","text":"<p>Tracks and stores ECG signals at the specified intervals.</p> <p>This method should be called at each time step of the simulation.</p>"},{"location":"api/ECG2DTracker/#finitewave.cpuwave2D.tracker.ecg_2d_tracker.ECG2DTracker.write","title":"<code>write()</code>","text":"<p>Saves the computed ECG signals to disk as a NumPy file.</p>"},{"location":"api/ECG3DTracker/","title":"ECG3DTracker","text":"<p>               Bases: <code>Tracker</code></p>"},{"location":"api/FibrosisPattern/","title":"FibrosisPattern","text":"<p>Abstract base class for generating and applying fibrosis patterns to cardiac tissue.</p> <p>This class defines an interface for creating fibrosis patterns and applying them to cardiac tissue models. Subclasses must implement the <code>generate</code> method to define specific patterns. The <code>apply</code> method uses the generated pattern to modify the mesh of the cardiac tissue.</p> <p>Methods:</p> Name Description <code>generate</code> <p>Abstract method to generate a fibrosis pattern based on the given size and optionally the mesh.</p> <code>apply</code> <p>Applies the generated fibrosis pattern to the provided cardiac tissue object.</p>"},{"location":"api/FibrosisPattern/#finitewave.core.fibrosis.fibrosis_pattern.FibrosisPattern.apply","title":"<code>apply(cardiac_tissue)</code>","text":"<p>Applies the generated fibrosis pattern to the specified cardiac tissue object.</p> <p>This method calls the <code>generate</code> method to create the pattern and then updates the <code>mesh</code> attribute of the <code>cardiac_tissue</code> object with the generated pattern.</p> <p>Parameters:</p> Name Type Description Default <code>cardiac_tissue</code> <code>CardiacTissue</code> <p>The cardiac tissue object to which the fibrosis pattern will be applied. The <code>mesh</code> attribute of this object will be updated with the generated pattern.</p> required"},{"location":"api/FibrosisPattern/#finitewave.core.fibrosis.fibrosis_pattern.FibrosisPattern.generate","title":"<code>generate(size, mesh=None)</code>  <code>abstractmethod</code>","text":"<p>Generates a fibrosis pattern for the given size and optionally based on the provided mesh.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>tuple</code> <p>The shape of the mesh (e.g., (ni, nj) or (ni, nj, nk)).</p> required <code>mesh</code> <code>ndarray</code> <p>The existing mesh to base the pattern on. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A new mesh array with the applied fibrosis pattern.</p>"},{"location":"api/IncorrectWeightsModeError2D/","title":"IncorrectWeightsModeError2D","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for invalid modes in the CardiacTissue2D class.</p> <p>Attributes:</p> Name Type Description <code>mode</code> <code>str</code> <p>The invalid mode that caused the exception.</p> <code>message</code> <code>str</code> <p>Explanation of the error.</p>"},{"location":"api/IncorrectWeightsModeError2D/#finitewave.cpuwave2D.exception.exceptions_2d.IncorrectWeightsModeError2D.__init__","title":"<code>__init__(mode, message=\"CardiacTissue2D mode attribute must be 'iso' or 'aniso'\")</code>","text":"<p>Initializes the IncorrectWeightsModeError2D exception.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>The invalid mode that caused the exception.</p> required <code>message</code> <code>str</code> <p>Explanation of the error (default is \"CardiacTissue2D mode attribute must be 'iso' or 'aniso'\").</p> <code>\"CardiacTissue2D mode attribute must be 'iso' or 'aniso'\"</code>"},{"location":"api/IncorrectWeightsModeError2D/#finitewave.cpuwave2D.exception.exceptions_2d.IncorrectWeightsModeError2D.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the exception.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string describing the error including the invalid mode.</p>"},{"location":"api/IncorrectWeightsShapeError/","title":"IncorrectWeightsShapeError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for errors in the shape of weights in the CardiacTissue class.</p> <p>This exception is used to indicate that the shape of weights provided does not match the expected dimensions. It includes details about the incorrect shape and the expected shapes.</p> <p>Attributes:</p> Name Type Description <code>shape</code> <code>tuple</code> <p>The incorrect shape of the weights that caused the error.</p> <code>n1</code> <code>int</code> <p>The expected number of weights in one of the dimensions.</p> <code>n2</code> <code>int</code> <p>The expected number of weights in another dimension.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the exception with the incorrect shape and the expected dimensions.</p>"},{"location":"api/IncorrectWeightsShapeError/#finitewave.core.exception.exceptions.IncorrectWeightsShapeError.__init__","title":"<code>__init__(shape, n1, n2)</code>","text":"<p>Initializes the IncorrectWeightsShapeError with details about the incorrect shape and expected dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple</code> <p>The actual shape of the weights array that is incorrect.</p> required <code>n1</code> <code>int</code> <p>The target number of weights in one dimension.</p> required <code>n2</code> <code>int</code> <p>The target number of weights in another dimension.</p> required"},{"location":"api/IsotropicStencil2D/","title":"IsotropicStencil2D","text":"<p>               Bases: <code>Stencil</code></p> <p>A class to represent a 2D isotropic stencil for diffusion processes.</p> Inherits from: <p>Stencil     Base class for different stencils used in diffusion calculations.</p> <p>Methods:</p> Name Description <code>get_weights</code> <p>Computes the weights for diffusion based on the isotropic stencil.</p>"},{"location":"api/IsotropicStencil2D/#finitewave.cpuwave2D.stencil.isotropic_stencil_2d.IsotropicStencil2D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the IsotropicStencil2D with default settings.</p>"},{"location":"api/IsotropicStencil2D/#finitewave.cpuwave2D.stencil.isotropic_stencil_2d.IsotropicStencil2D.get_weights","title":"<code>get_weights(mesh, conductivity, fibers, D_al, D_ac, dt, dr)</code>","text":"<p>Computes the weights for diffusion on a 2D mesh using an isotropic stencil.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>ndarray</code> <p>2D array representing the mesh grid of the tissue. Non-tissue areas are set to 0.</p> required <code>conductivity</code> <code>float</code> <p>Conductivity of the tissue, which scales the diffusion coefficient.</p> required <code>fibers</code> <code>ndarray</code> <p>Array representing fiber orientations. Not used in isotropic stencil but kept for consistency.</p> required <code>D_al</code> <code>float</code> <p>Longitudinal diffusion coefficient.</p> required <code>D_ac</code> <code>float</code> <p>Cross-sectional diffusion coefficient. Not used in isotropic stencil but kept for consistency.</p> required <code>dt</code> <code>float</code> <p>Temporal resolution.</p> required <code>dr</code> <code>float</code> <p>Spatial resolution.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3D array of weights for diffusion, with the shape of (mesh.shape[0], mesh.shape[1], 5).</p> Notes <p>The method assumes isotropic diffusion where <code>D_al</code> is used as the diffusion coefficient. The weights are computed for four directions (up, right, down, left) and the central weight. Heterogeneity in the diffusion coefficients is handled by adjusting the weights based on differences in the diffusion coefficients along the rows and columns.</p>"},{"location":"api/IsotropicStencil3D/","title":"IsotropicStencil3D","text":"<p>               Bases: <code>Stencil</code></p> <p>A class to represent a 3D isotropic stencil for diffusion processes.</p> Inherits from: <p>Stencil     Base class for different stencils used in diffusion calculations.</p> <p>Methods:</p> Name Description <code>get_weights</code> <p>Computes the weights for diffusion based on the isotropic stencil.</p>"},{"location":"api/IsotropicStencil3D/#finitewave.cpuwave3D.stencil.isotropic_stencil_3d.IsotropicStencil3D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the IsotropicStencil3D with default settings.</p>"},{"location":"api/IsotropicStencil3D/#finitewave.cpuwave3D.stencil.isotropic_stencil_3d.IsotropicStencil3D.get_weights","title":"<code>get_weights(mesh, conductivity, fibers, D_al, D_ac, dt, dr)</code>","text":"<p>Computes the weights for diffusion on a 3D mesh using an isotropic stencil.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>ndarray</code> <p>3D array representing the mesh grid of the tissue. Non-tissue areas are set to 0.</p> required <code>conductivity</code> <code>float</code> <p>Conductivity of the tissue, which scales the diffusion coefficient.</p> required <code>fibers</code> <code>ndarray</code> <p>Array representing fiber orientations. Not used in isotropic stencil but kept for consistency.</p> required <code>D_al</code> <code>float</code> <p>Longitudinal diffusion coefficient.</p> required <code>D_ac</code> <code>float</code> <p>Cross-sectional diffusion coefficient. Not used in isotropic stencil but kept for consistency.</p> required <code>dt</code> <code>float</code> <p>Temporal resolution.</p> required <code>dr</code> <code>float</code> <p>Spatial resolution.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>4D array of weights for diffusion, with the shape of (mesh.shape[0], mesh.shape[1], 7).</p> Notes <p>The method assumes isotropic diffusion where <code>D_al</code> is used as the diffusion coefficient. The weights are computed for four directions (up, right, down, left) and the central weight. Heterogeneity in the diffusion coefficients is handled by adjusting the weights based on differences in the diffusion coefficients along the rows and columns.</p>"},{"location":"api/LuoRudy912D/","title":"LuoRudy912D","text":"<p>               Bases: <code>CardiacModel</code></p> <p>Implements the 2D Luo-Rudy 1991 cardiac model for simulating cardiac electrical activity.</p> <p>This class initializes the state variables and provides methods for running simulations with the Luo-Rudy 1991 model.</p> <p>Attributes:</p> Name Type Description <code>m</code> <code>ndarray</code> <p>Gating variable m.</p> <code>h</code> <code>ndarray</code> <p>Gating variable h.</p> <code>j_</code> <code>ndarray</code> <p>Gating variable j_.</p> <code>d</code> <code>ndarray</code> <p>Gating variable d.</p> <code>f</code> <code>ndarray</code> <p>Gating variable f.</p> <code>x</code> <code>ndarray</code> <p>Gating variable x.</p> <code>Cai_c</code> <code>ndarray</code> <p>Intracellular calcium concentration.</p> <code>model_parameters</code> <code>dict</code> <p>Dictionary to hold model-specific parameters.</p> <code>state_vars</code> <code>list</code> <p>List of state variable names.</p> <code>npfloat</code> <code>str</code> <p>NumPy data type used for floating point calculations ('float64').</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the state variables and sets up the diffusion and ionic kernels.</p> <code>run_ionic_kernel</code> <p>Executes the ionic kernel to update the state variables and membrane potential.</p>"},{"location":"api/LuoRudy912D/#finitewave.cpuwave2D.model.luo_rudy91_2d.luo_rudy91_2d.LuoRudy912D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the LuoRudy912D instance, setting up the state variables and parameters.</p>"},{"location":"api/LuoRudy912D/#finitewave.cpuwave2D.model.luo_rudy91_2d.luo_rudy91_2d.LuoRudy912D.initialize","title":"<code>initialize()</code>","text":"<p>Initializes the state variables and sets up the diffusion and ionic kernels.</p> <p>This method sets the initial values for the membrane potential <code>u</code>, gating variables <code>m</code>, <code>h</code>, <code>j_</code>, <code>d</code>, <code>f</code>, <code>x</code>,  and intracellular calcium concentration <code>Cai_c</code>. It also retrieves and sets the diffusion and ionic kernel functions based on the shape of the weights in the cardiac tissue.</p>"},{"location":"api/LuoRudy912D/#finitewave.cpuwave2D.model.luo_rudy91_2d.luo_rudy91_2d.LuoRudy912D.run_ionic_kernel","title":"<code>run_ionic_kernel()</code>","text":"<p>Executes the ionic kernel to update the state variables and membrane potential.</p> <p>This method calls the ionic kernel function provided by the <code>LuoRudy91Kernels2D</code> class to compute the updates for the membrane potential <code>u_new</code> and the gating variables <code>m</code>, <code>h</code>, <code>j_</code>, <code>d</code>, <code>f</code>, <code>x</code>, and <code>Cai_c</code> based on the current state and the time step <code>dt</code>.</p> <p>The ionic kernel function takes the following parameters: - <code>u_new</code>: Array to store updated membrane potential values. - <code>u</code>: Array of current membrane potential values. - <code>m</code>: Array of gating variable m. - <code>h</code>: Array of gating variable h. - <code>j_</code>: Array of gating variable j_. - <code>d</code>: Array of gating variable d. - <code>f</code>: Array of gating variable f. - <code>x</code>: Array of gating variable x. - <code>Cai_c</code>: Array of intracellular calcium concentration. - <code>mesh</code>: Array indicating tissue types. - <code>dt</code>: Time step for the simulation.</p>"},{"location":"api/LuoRudy913D/","title":"LuoRudy913D","text":"<p>               Bases: <code>CardiacModel</code></p> <p>Implements the 3D Luo-Rudy 1991 cardiac model for simulating cardiac electrical activity.</p> <p>This class initializes the state variables and provides methods for running simulations with the Luo-Rudy 1991 model.</p> <p>Attributes:</p> Name Type Description <code>m</code> <code>ndarray</code> <p>Gating variable m.</p> <code>h</code> <code>ndarray</code> <p>Gating variable h.</p> <code>j_</code> <code>ndarray</code> <p>Gating variable j_.</p> <code>d</code> <code>ndarray</code> <p>Gating variable d.</p> <code>f</code> <code>ndarray</code> <p>Gating variable f.</p> <code>x</code> <code>ndarray</code> <p>Gating variable x.</p> <code>Cai_c</code> <code>ndarray</code> <p>Intracellular calcium concentration.</p> <code>model_parameters</code> <code>dict</code> <p>Dictionary to hold model-specific parameters.</p> <code>state_vars</code> <code>list</code> <p>List of state variable names.</p> <code>npfloat</code> <code>str</code> <p>NumPy data type used for floating point calculations ('float64').</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the state variables and sets up the diffusion and ionic kernels.</p> <code>run_ionic_kernel</code> <p>Executes the ionic kernel to update the state variables and membrane potential.</p>"},{"location":"api/LuoRudy913D/#finitewave.cpuwave3D.model.luo_rudy91_3d.luo_rudy91_3d.LuoRudy913D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the LuoRudy913D instance, setting up the state variables and parameters.</p>"},{"location":"api/LuoRudy913D/#finitewave.cpuwave3D.model.luo_rudy91_3d.luo_rudy91_3d.LuoRudy913D.initialize","title":"<code>initialize()</code>","text":"<p>Initializes the state variables and sets up the diffusion and ionic kernels.</p> <p>This method sets the initial values for the membrane potential <code>u</code>, gating variables <code>m</code>, <code>h</code>, <code>j_</code>, <code>d</code>, <code>f</code>, <code>x</code>,  and intracellular calcium concentration <code>Cai_c</code>. It also retrieves and sets the diffusion and ionic kernel functions based on the shape of the weights in the cardiac tissue.</p>"},{"location":"api/LuoRudy913D/#finitewave.cpuwave3D.model.luo_rudy91_3d.luo_rudy91_3d.LuoRudy913D.run_ionic_kernel","title":"<code>run_ionic_kernel()</code>","text":"<p>Executes the ionic kernel to update the state variables and membrane potential.</p> <p>This method calls the ionic kernel function provided by the <code>LuoRudy91Kernels3D</code> class to compute the updates for the membrane potential <code>u_new</code> and the gating variables <code>m</code>, <code>h</code>, <code>j_</code>, <code>d</code>, <code>f</code>, <code>x</code>, and <code>Cai_c</code> based on the current state and the time step <code>dt</code>.</p> <p>The ionic kernel function takes the following parameters: - <code>u_new</code>: Array to store updated membrane potential values. - <code>u</code>: Array of current membrane potential values. - <code>m</code>: Array of gating variable m. - <code>h</code>: Array of gating variable h. - <code>j_</code>: Array of gating variable j_. - <code>d</code>: Array of gating variable d. - <code>f</code>: Array of gating variable f. - <code>x</code>: Array of gating variable x. - <code>Cai_c</code>: Array of intracellular calcium concentration. - <code>mesh</code>: Array indicating tissue types. - <code>dt</code>: Time step for the simulation.</p>"},{"location":"api/LuoRudy91Kernels2D/","title":"LuoRudy91Kernels2D","text":"<p>Class to handle kernel functions for the Luo-Rudy 1991 cardiac model in 2D.</p> <p>This class provides methods to obtain the appropriate diffusion and ionic kernels based on the shape of the weight array.</p> <p>Methods:</p> Name Description <code>get_diffuse_kernel</code> <p>Returns the diffusion kernel function based on the weight array shape.</p> <code>get_ionic_kernel</code> <p>Returns the ionic kernel function used for updating membrane potentials and gating variables.</p>"},{"location":"api/LuoRudy91Kernels2D/#finitewave.cpuwave2D.model.luo_rudy91_2d.luo_rudy91_kernels_2d.LuoRudy91Kernels2D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the LuoRudy91Kernels2D instance.</p>"},{"location":"api/LuoRudy91Kernels2D/#finitewave.cpuwave2D.model.luo_rudy91_2d.luo_rudy91_kernels_2d.LuoRudy91Kernels2D.get_diffuse_kernel","title":"<code>get_diffuse_kernel(shape)</code>  <code>staticmethod</code>","text":"<p>Retrieves the diffusion kernel function based on the weight shape.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple</code> <p>The shape of the weight array used in the diffusion process.</p> required <p>Returns:</p> Type Description <code>function</code> <p>The diffusion kernel function appropriate for the given weight shape.</p> <p>Raises:</p> Type Description <code>IncorrectWeightsShapeError</code> <p>If the shape of the weights array does not match expected values (5 or 9).</p>"},{"location":"api/LuoRudy91Kernels2D/#finitewave.cpuwave2D.model.luo_rudy91_2d.luo_rudy91_kernels_2d.LuoRudy91Kernels2D.get_ionic_kernel","title":"<code>get_ionic_kernel()</code>  <code>staticmethod</code>","text":"<p>Retrieves the ionic kernel function for updating membrane potentials and gating variables.</p> <p>Returns:</p> Type Description <code>function</code> <p>The ionic kernel function used in the Luo-Rudy 1991 model.</p>"},{"location":"api/LuoRudy91Kernels3D/","title":"LuoRudy91Kernels3D","text":"<p>Class to handle kernel functions for the Luo-Rudy 1991 cardiac model in 3D.</p> <p>This class provides methods to obtain the appropriate diffusion and ionic kernels based on the shape of the weight array.</p> <p>Methods:</p> Name Description <code>get_diffuse_kernel</code> <p>Returns the diffusion kernel function based on the weight array shape.</p> <code>get_ionic_kernel</code> <p>Returns the ionic kernel function used for updating membrane potentials and gating variables.</p>"},{"location":"api/LuoRudy91Kernels3D/#finitewave.cpuwave3D.model.luo_rudy91_3d.luo_rudy91_kernels_3d.LuoRudy91Kernels3D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the LuoRudy91Kernels3D instance.</p>"},{"location":"api/LuoRudy91Kernels3D/#finitewave.cpuwave3D.model.luo_rudy91_3d.luo_rudy91_kernels_3d.LuoRudy91Kernels3D.get_diffuse_kernel","title":"<code>get_diffuse_kernel(shape)</code>  <code>staticmethod</code>","text":"<p>Retrieves the diffusion kernel function based on the weight shape.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple</code> <p>The shape of the weight array used in the diffusion process.</p> required <p>Returns:</p> Type Description <code>function</code> <p>The diffusion kernel function appropriate for the given weight shape.</p> <p>Raises:</p> Type Description <code>IncorrectWeightsShapeError</code> <p>If the shape of the weights array does not match expected values (7 or 19).</p>"},{"location":"api/LuoRudy91Kernels3D/#finitewave.cpuwave3D.model.luo_rudy91_3d.luo_rudy91_kernels_3d.LuoRudy91Kernels3D.get_ionic_kernel","title":"<code>get_ionic_kernel()</code>  <code>staticmethod</code>","text":"<p>Retrieves the ionic kernel function for updating membrane potentials and gating variables.</p> <p>Returns:</p> Type Description <code>function</code> <p>The ionic kernel function used in the Luo-Rudy 1991 model.</p>"},{"location":"api/MultiActivationTime2DTracker/","title":"MultiActivationTime2DTracker","text":"<p>               Bases: <code>Tracker</code></p> <p>A class to compute and track multiple activation times in a 2D cardiac tissue model simulation.</p> <p>This tracker monitors the potential across the cardiac tissue and records the times when cells surpass a specific threshold, supporting multiple activations such as re-entrant waves or multiple excitations.</p> <p>Attributes:</p> Name Type Description <code>act_t</code> <code>list of np.ndarray</code> <p>A list where each element is an array storing activation times for each cell.</p> <code>threshold</code> <code>float</code> <p>The potential threshold to determine cell activation.</p> <code>file_name</code> <code>str</code> <p>The file name for saving the activation times.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the tracker with the simulation model and precomputes necessary values.</p> <code>track</code> <p>Tracks and stores activation times for each cell in the model at each time step.</p> <code>output:</code> <p>Returns the activation times.</p> <code>write</code> <p>Saves the activation times to disk as a NumPy file.</p>"},{"location":"api/MultiActivationTime2DTracker/#finitewave.cpuwave2D.tracker.multi_activation_time_2d_tracker.MultiActivationTime2DTracker.output","title":"<code>output</code>  <code>property</code>","text":"<p>Returns the activation times.</p> <p>Returns:</p> Type Description <code>list of np.ndarray</code> <p>A list where each element is an array storing activation times for each cell.</p>"},{"location":"api/MultiActivationTime2DTracker/#finitewave.cpuwave2D.tracker.multi_activation_time_2d_tracker.MultiActivationTime2DTracker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the MultiActivationTime2DTracker with default parameters.</p>"},{"location":"api/MultiActivationTime2DTracker/#finitewave.cpuwave2D.tracker.multi_activation_time_2d_tracker.MultiActivationTime2DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the tracker with the simulation model and precomputes necessary values.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model object containing the data to be tracked.</p> required"},{"location":"api/MultiVariable2DTracker/","title":"MultiVariable2DTracker","text":"<p>               Bases: <code>Tracker</code></p> <p>A class to track multiple variables at a specific cell in a 2D cardiac tissue model simulation.</p> <p>This tracker monitors user-defined variables at a specified cell index and records their values over time.</p> <p>Attributes:</p> Name Type Description <code>var_list</code> <code>list of str</code> <p>A list of variable names to be tracked.</p> <code>cell_ind</code> <code>list of int</code> <p>The indices [i, j] of the cell where the variables are tracked.</p> <code>dir_name</code> <code>str</code> <p>The directory name where tracked variables are saved.</p> <code>vars</code> <code>dict</code> <p>A dictionary where each key is a variable name, and the value is an array of its tracked values over time.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the tracker with the simulation model and precomputes necessary values for each variable.</p> <code>track</code> <p>Tracks and stores the values of each specified variable at each time step.</p> <code>write</code> <p>Saves the tracked variables to disk as NumPy files.</p>"},{"location":"api/MultiVariable2DTracker/#finitewave.cpuwave2D.tracker.multi_variable_2d_tracker.MultiVariable2DTracker.output","title":"<code>output</code>  <code>property</code>","text":"<p>Returns the tracked variables data.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary where each key is a variable name, and the value is an array of its tracked values over time.</p>"},{"location":"api/MultiVariable2DTracker/#finitewave.cpuwave2D.tracker.multi_variable_2d_tracker.MultiVariable2DTracker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the MultiVariable2DTracker with default parameters.</p>"},{"location":"api/MultiVariable2DTracker/#finitewave.cpuwave2D.tracker.multi_variable_2d_tracker.MultiVariable2DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the tracker with the simulation model and precomputes necessary values for each variable.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model object containing the data to be tracked.</p> required"},{"location":"api/MultiVariable2DTracker/#finitewave.cpuwave2D.tracker.multi_variable_2d_tracker.MultiVariable2DTracker.write","title":"<code>write()</code>","text":"<p>Saves the tracked variables to disk as NumPy files.</p>"},{"location":"api/Period2DTracker/","title":"Period2DTracker","text":"<p>               Bases: <code>Tracker</code></p> <p>A class to track activation periods of cells in a 2D cardiac tissue model using detectors.</p> <p>Attributes:</p> Name Type Description <code>detectors</code> <code>ndarray</code> <p>Binary array indicating the placement of detectors on the mesh.</p> <code>threshold</code> <code>float</code> <p>The threshold potential value for detecting activations.</p> <code>_periods</code> <code>ndarray</code> <p>Array to store the activation times for each detector.</p> <code>_detectors_state</code> <code>ndarray</code> <p>Binary array indicating the state of detectors (1 if below threshold, 0 if above).</p> <code>_step</code> <code>int</code> <p>The current index for storing activation periods.</p> <code>file_name</code> <code>str</code> <p>The file name to save the tracked activation periods.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the tracker with the simulation model and preallocates memory for tracking.</p> <code>track</code> <p>Tracks the activation periods at each time step of the simulation.</p> <code>compute_periods</code> <p>Computes the time intervals between successive activations for each detector.</p> <code>output</code> <p>Property to get the computed activation periods.</p> <code>write</code> <p>Saves the computed activation periods to a JSON file.</p>"},{"location":"api/Period2DTracker/#finitewave.cpuwave2D.tracker.period_2d_tracker.Period2DTracker.output","title":"<code>output</code>  <code>property</code>","text":"<p>Property to get the computed activation periods.</p>"},{"location":"api/Period2DTracker/#finitewave.cpuwave2D.tracker.period_2d_tracker.Period2DTracker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Period2DTracker with default parameters.</p>"},{"location":"api/Period2DTracker/#finitewave.cpuwave2D.tracker.period_2d_tracker.Period2DTracker.compute_periods","title":"<code>compute_periods()</code>","text":"<p>Computes the time intervals between successive activations for each detector.</p> <p>Returns:</p> Name Type Description <code>periods_dict</code> <code>dict</code> <p>A dictionary where each key is a detector's coordinates and each value is a list of activation times and periods.</p>"},{"location":"api/Period2DTracker/#finitewave.cpuwave2D.tracker.period_2d_tracker.Period2DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the tracker with the simulation model and preallocates memory for tracking.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model object containing the data to be tracked.</p> required"},{"location":"api/Period2DTracker/#finitewave.cpuwave2D.tracker.period_2d_tracker.Period2DTracker.track","title":"<code>track()</code>","text":"<p>Tracks the activation periods at each time step of the simulation.</p> <p>This method dynamically expands the periods array if necessary and updates the periods and detectors state arrays.</p>"},{"location":"api/Period2DTracker/#finitewave.cpuwave2D.tracker.period_2d_tracker.Period2DTracker.write","title":"<code>write()</code>","text":"<p>Saves the computed activation periods to a JSON file.</p>"},{"location":"api/Period3DTracker/","title":"Period3DTracker","text":"<p>               Bases: <code>Tracker</code></p>"},{"location":"api/PeriodMap2DTracker/","title":"PeriodMap2DTracker","text":"<p>               Bases: <code>Animation2DTracker</code></p> <p>A class to track the periods of activation for each cell in a 2D cardiac tissue model.</p> <p>This class extends Animation2DTracker to create and save a period map that shows the time interval between successive activations of each cell that crosses a given threshold. The period map is saved at each time step.</p> <p>Attributes:</p> Name Type Description <code>threshold</code> <code>float</code> <p>The threshold potential value for detecting activations.</p> <code>period_map</code> <code>ndarray</code> <p>2D array to store the time interval between successive activations for each cell.</p> <code>_period_map_state</code> <code>ndarray</code> <p>2D array to store the current state of each cell (1 if below threshold, 0 if above).</p> <code>_last_time_map</code> <code>ndarray</code> <p>2D array to store the last activation time for each cell.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the tracker with the simulation model and preallocates memory for tracking.</p> <code>track</code> <p>Tracks the activation periods at each time step of the simulation and saves them to files.</p> <code>write</code> <p>Overridden method to handle file writing, here it's empty.</p>"},{"location":"api/PeriodMap2DTracker/#finitewave.cpuwave2D.tracker.period_map_2d_tracker.PeriodMap2DTracker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the PeriodMap2DTracker with default parameters.</p>"},{"location":"api/PeriodMap2DTracker/#finitewave.cpuwave2D.tracker.period_map_2d_tracker.PeriodMap2DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the tracker with the simulation model and preallocates memory for tracking.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model object containing the data to be tracked.</p> required"},{"location":"api/PeriodMap2DTracker/#finitewave.cpuwave2D.tracker.period_map_2d_tracker.PeriodMap2DTracker.track","title":"<code>track()</code>","text":"<p>Tracks the activation periods at each time step of the simulation.</p> <p>This method calculates the time interval between successive activations for each cell, updates the period map, and saves it to a file.</p>"},{"location":"api/PeriodMap2DTracker/#finitewave.cpuwave2D.tracker.period_map_2d_tracker.PeriodMap2DTracker.write","title":"<code>write()</code>","text":"<p>Overridden write method.</p> <p>This method is intentionally left empty because the write functionality is handled in the track method.</p>"},{"location":"api/PeriodMap3DTracker/","title":"PeriodMap3DTracker","text":"<p>               Bases: <code>AnimationSlice3DTracker</code></p>"},{"location":"api/PotentialPeriodAnimationBuilder/","title":"PotentialPeriodAnimationBuilder","text":""},{"location":"api/RotationalAnisotropy/","title":"RotationalAnisotropy","text":"<p>A class to generate fiber orientations in a 3D space based on rotational anisotropy.</p> <p>Attributes:</p> Name Type Description <code>size</code> <code>list of int</code> <p>A list defining the dimensions of the 3D grid (x, y, z).</p> <code>alpha</code> <code>list of float</code> <p>A list with two elements defining the range of rotation angles in degrees.</p> <code>axis</code> <code>int</code> <p>The axis along which the rotation will be applied (0 for x, 1 for y, 2 for z).</p> <code>init_v</code> <code>list of float</code> <p>The initial vector along which the fibers are oriented.</p> <p>Methods:</p> Name Description <code>generate_fibers</code> <p>Generates and returns a 3D array of fibers with rotational anisotropy applied.</p> <code>test</code> <p>Visualizes the generated fibers using a 3D quiver plot.</p>"},{"location":"api/RotationalAnisotropy/#finitewave.cpuwave3D.fibers.rotational_anisotropy.RotationalAnisotropy.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the RotationalAnisotropy object with default values.</p>"},{"location":"api/RotationalAnisotropy/#finitewave.cpuwave3D.fibers.rotational_anisotropy.RotationalAnisotropy.generate_fibers","title":"<code>generate_fibers()</code>","text":"<p>Generates a 3D array of fiber orientations based on rotational anisotropy.</p> <p>The fibers are initially aligned along <code>init_v</code> and then rotated according to the  specified range of angles (<code>alpha</code>) along the specified axis (<code>axis</code>).</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>A 4D NumPy array of shape (size[0], size[1], size[2], 3) containing the fiber vectors.</p>"},{"location":"api/RotationalAnisotropy/#finitewave.cpuwave3D.fibers.rotational_anisotropy.RotationalAnisotropy.test","title":"<code>test(fibers)</code>","text":"<p>Visualizes the generated fibers using a 3D quiver plot.</p> <p>Parameters:</p> Name Type Description Default <code>fibers</code> <code>ndarray</code> <p>A 4D NumPy array of shape (size[0], size[1], size[2], 3) containing the fiber vectors.</p> required"},{"location":"api/ScarGauss2DPattern/","title":"ScarGauss2DPattern","text":"<p>               Bases: <code>FibrosisPattern</code></p> <p>Class for generating a 2D fibrosis pattern using a Gaussian distribution.</p> <p>Attributes:</p> Name Type Description <code>mean</code> <code>list of float</code> <p>The mean values for the Gaussian distribution in the x and y dimensions.</p> <code>std</code> <code>list of float</code> <p>The standard deviations for the Gaussian distribution in the x and y dimensions.</p> <code>corr</code> <code>float</code> <p>The correlation coefficient between the x and y dimensions of the Gaussian distribution.</p> <code>size</code> <code>tuple of int</code> <p>The size of the Gaussian distribution sample.</p> <p>Methods:</p> Name Description <code>generate</code> <p>Generates the Gaussian fibrosis pattern and updates the provided mesh. If no mesh is provided,  a new mesh is created with the given size.</p>"},{"location":"api/ScarGauss2DPattern/#finitewave.cpuwave2D.fibrosis.scar_gauss_2d_pattern.ScarGauss2DPattern.__init__","title":"<code>__init__(mean, std, corr, size)</code>","text":"<p>Initializes the ScarGauss2DPattern with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>list of float</code> <p>The mean values for the Gaussian distribution in the x and y dimensions.</p> required <code>std</code> <code>list of float</code> <p>The standard deviations for the Gaussian distribution in the x and y dimensions.</p> required <code>corr</code> <code>float</code> <p>The correlation coefficient between the x and y dimensions of the Gaussian distribution.</p> required <code>size</code> <code>tuple of int</code> <p>The size of the Gaussian distribution sample.</p> required"},{"location":"api/ScarGauss2DPattern/#finitewave.cpuwave2D.fibrosis.scar_gauss_2d_pattern.ScarGauss2DPattern.generate","title":"<code>generate(size, mesh=None)</code>","text":"<p>Generates and applies the Gaussian fibrosis pattern to the mesh.</p> <p>If no mesh is provided, a new mesh of zeros with the given size is created. The method  generates a Gaussian distribution of fibrosis locations and applies them to the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>tuple of int</code> <p>The size of the mesh to create if no mesh is provided.</p> required <code>mesh</code> <code>ndarray</code> <p>The mesh to which the fibrosis pattern is applied. If None, a new mesh is created  with the given size.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The mesh with the applied Gaussian fibrosis pattern.</p>"},{"location":"api/ScarRect2DPattern/","title":"ScarRect2DPattern","text":"<p>               Bases: <code>FibrosisPattern</code></p> <p>Class for generating a rectangular fibrosis pattern in a 2D mesh.</p> <p>Attributes:</p> Name Type Description <code>x1</code> <code>int</code> <p>The starting x-coordinate of the rectangular region.</p> <code>x2</code> <code>int</code> <p>The ending x-coordinate of the rectangular region.</p> <code>y1</code> <code>int</code> <p>The starting y-coordinate of the rectangular region.</p> <code>y2</code> <code>int</code> <p>The ending y-coordinate of the rectangular region.</p> <p>Methods:</p> Name Description <code>generate</code> <p>Generates a rectangular fibrosis pattern and updates the provided mesh. If no mesh is provided,  a new mesh is created with the given size.</p>"},{"location":"api/ScarRect2DPattern/#finitewave.cpuwave2D.fibrosis.scar_rect_2d_pattern.ScarRect2DPattern.__init__","title":"<code>__init__(x1, x2, y1, y2)</code>","text":"<p>Initializes the ScarRect2DPattern with the specified rectangular region.</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>int</code> <p>The starting x-coordinate of the rectangular region.</p> required <code>x2</code> <code>int</code> <p>The ending x-coordinate of the rectangular region.</p> required <code>y1</code> <code>int</code> <p>The starting y-coordinate of the rectangular region.</p> required <code>y2</code> <code>int</code> <p>The ending y-coordinate of the rectangular region.</p> required"},{"location":"api/ScarRect2DPattern/#finitewave.cpuwave2D.fibrosis.scar_rect_2d_pattern.ScarRect2DPattern.generate","title":"<code>generate(size, mesh=None)</code>","text":"<p>Generates and applies a rectangular fibrosis pattern to the mesh.</p> <p>If no mesh is provided, a new mesh of zeros with the given size is created. The method  generates a rectangular region of fibrosis and applies it to the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>tuple of int</code> <p>The size of the mesh to create if no mesh is provided.</p> required <code>mesh</code> <code>ndarray</code> <p>The mesh to which the fibrosis pattern is applied. If None, a new mesh is created  with the given size.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The mesh with the applied rectangular fibrosis pattern.</p>"},{"location":"api/Spiral2DTracker/","title":"Spiral2DTracker","text":"<p>               Bases: <code>Tracker</code></p> <p>A class to track spiral wave tips in a 2D cardiac tissue model.</p> <p>This tracker identifies and records the positions of spiral wave tips by analyzing voltage isoline crossings in the simulated 2D grid over time.</p> <p>Attributes:</p> Name Type Description <code>size_i, size_j</code> <code>int</code> <p>Dimensions of the 2D grid.</p> <code>dr</code> <code>float</code> <p>Grid spacing in the model.</p> <code>threshold</code> <code>float</code> <p>Voltage threshold value for detecting spiral tips.</p> <code>file_name</code> <code>str</code> <p>Name of the output file where spiral tip data is saved.</p> <code>swcore</code> <code>list</code> <p>List to store detected spiral wave core positions.</p> <code>all</code> <code>bool</code> <p>Flag to determine whether all tips or only first few are tracked.</p> <code>step</code> <code>int</code> <p>Interval of steps for saving the spiral wave tips.</p> <code>_t</code> <code>float</code> <p>Internal timer to track the current simulation time.</p> <code>_u_prev_step</code> <code>ndarray</code> <p>Array to store the voltage values from the previous time step.</p> <code>_tipdata</code> <code>ndarray</code> <p>Array to store the detected tip coordinates.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the tracker with the simulation model.</p> <code>track_tipline</code> <p>Wrapper function for the low-level _track_tipline function.</p> <code>track</code> <p>Tracks spiral tips at each simulation step.</p> <code>write</code> <p>Saves the tracked spiral tip data to a file.</p> <code>output:</code> <p>Property that returns the tracked spiral core data.</p>"},{"location":"api/Spiral2DTracker/#finitewave.cpuwave2D.tracker.spiral_2d_tracker.Spiral2DTracker.output","title":"<code>output</code>  <code>property</code>","text":"<p>Get the tracked spiral core data.</p> <p>Returns:</p> Type Description <code>list</code> <p>List of tracked spiral core data.</p>"},{"location":"api/Spiral2DTracker/#finitewave.cpuwave2D.tracker.spiral_2d_tracker.Spiral2DTracker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Spiral2DTracker with default parameters.</p>"},{"location":"api/Spiral2DTracker/#finitewave.cpuwave2D.tracker.spiral_2d_tracker.Spiral2DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initialize the tracker with the given cardiac tissue model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue simulation model containing the grid and voltage data.</p> required"},{"location":"api/Spiral2DTracker/#finitewave.cpuwave2D.tracker.spiral_2d_tracker.Spiral2DTracker.track","title":"<code>track()</code>","text":"<p>Track spiral tips at each simulation step by analyzing voltage data.</p> <p>The tracker is updated at each simulation step, detecting any spiral tips based on the voltage data from the previous and current steps.</p>"},{"location":"api/Spiral2DTracker/#finitewave.cpuwave2D.tracker.spiral_2d_tracker.Spiral2DTracker.track_tipline","title":"<code>track_tipline(var1, var2, tipvals, tipdata, tipsfound)</code>","text":"<p>High-level function to track spiral tips in the 2D grid.</p> <p>Parameters:</p> Name Type Description Default <code>var1</code> <code>ndarray</code> <p>2D arrays representing the old and new voltage values.</p> required <code>var2</code> <code>ndarray</code> <p>2D arrays representing the old and new voltage values.</p> required <code>tipvals</code> <code>list of float</code> <p>Isoline voltage values used for detecting spiral tips.</p> required <code>tipdata</code> <code>ndarray</code> <p>Array to store the coordinates of detected tips.</p> required <code>tipsfound</code> <code>int</code> <p>Counter for the number of detected tips.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Updated array of detected tip coordinates and the count of detected tips.</p>"},{"location":"api/Spiral2DTracker/#finitewave.cpuwave2D.tracker.spiral_2d_tracker.Spiral2DTracker.write","title":"<code>write()</code>","text":"<p>Save the tracked spiral tip data to a file.</p>"},{"location":"api/Spiral3DTracker/","title":"Spiral3DTracker","text":"<p>               Bases: <code>Tracker</code></p>"},{"location":"api/StateKeeper/","title":"StateKeeper","text":"<p>Handles saving and loading the state of a simulation model.</p> <p>This class provides functionality to save and load the state of a simulation model, including all relevant variables specified in the model's <code>state_vars</code> attribute. It handles file operations for saving to and loading from numpy <code>.npy</code> files.</p> <p>Attributes:</p> Name Type Description <code>record_save</code> <code>str</code> <p>Directory path where the simulation state will be saved.</p> <code>record_load</code> <code>str</code> <p>Directory path from where the simulation state will be loaded.</p> <p>Methods:</p> Name Description <code>save</code> <p>Saves the state of the provided model to the specified directory.</p> <code>load</code> <p>Loads the state from the specified directory and sets the state variables in the provided model.</p> <code>_save_variable</code> <p>Helper method to save a variable to a numpy <code>.npy</code> file.</p> <code>_load_variable</code> <p>Helper method to load a variable from a numpy <code>.npy</code> file.</p>"},{"location":"api/StateKeeper/#finitewave.core.state.state_keeper.StateKeeper.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the StateKeeper with default paths for saving and loading state.</p>"},{"location":"api/StateKeeper/#finitewave.core.state.state_keeper.StateKeeper.load","title":"<code>load(model)</code>","text":"<p>Loads the state from the specified <code>record_load</code> directory and sets it in the given model.</p> <p>This method loads each variable listed in the model's <code>state_vars</code> attribute from numpy <code>.npy</code> files and sets these variables in the model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The model object to which the state is to be loaded. The model must have a <code>state_vars</code> attribute which will be updated with the loaded variables.</p> required"},{"location":"api/StateKeeper/#finitewave.core.state.state_keeper.StateKeeper.save","title":"<code>save(model)</code>","text":"<p>Saves the state of the given model to the specified <code>record_save</code> directory.</p> <p>This method creates the necessary directories if they do not exist and saves each variable listed in the model's <code>state_vars</code> attribute as a numpy <code>.npy</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The model object whose state is to be saved. The model must have a <code>state_vars</code> attribute listing the state variables to be saved.</p> required"},{"location":"api/Stencil/","title":"Stencil","text":"<p>Base class for calculating stencil weights used in numerical simulations.</p> <p>This abstract base class defines the interface for calculating stencil weights for numerical simulations. It includes a caching mechanism to optimize performance by reducing the number of symbolic calculations.</p> <p>Attributes:</p> Name Type Description <code>cache</code> <code>dict</code> <p>A dictionary used to cache previously computed stencil weights to improve performance by avoiding redundant calculations.</p> <p>Methods:</p> Name Description <code>get_weights</code> <p>Abstract method that must be implemented by subclasses to compute and return stencil weights.</p>"},{"location":"api/Stencil/#finitewave.core.stencil.stencil.Stencil.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Stencil object with an empty cache.</p>"},{"location":"api/Stencil/#finitewave.core.stencil.stencil.Stencil.get_weights","title":"<code>get_weights(mesh, conductivity, fibers, D_al, D_ac, dt, dr)</code>  <code>abstractmethod</code>","text":"<p>Computes and returns the stencil weights based on the provided parameters.</p> <p>This method must be implemented by subclasses to compute the stencil weights used for numerical simulations. The weights are calculated based on the tissue mesh, conductivity, fibers orientation, diffusion coefficients, time step, and spatial step.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>ndarray</code> <p>A 2D or 3D numpy array representing the tissue mesh where each value indicates the type of tissue (e.g., cardiomyocyte, fibrosis).</p> required <code>conductivity</code> <code>ndarray or float</code> <p>A numpy array or constant value representing the coefficient for imitating low conductance (fibrosis) areas. This affects the diffusion coefficients.</p> required <code>fibers</code> <code>ndarray</code> <p>A 2D or 3D numpy array representing the orientation vectors of the fibers within the tissue.</p> required <code>D_al</code> <code>float</code> <p>The diffusion coefficient along the fibers direction.</p> required <code>D_ac</code> <code>float</code> <p>The diffusion coefficient across the fibers direction.</p> required <code>dt</code> <code>float</code> <p>The time step used in the simulation.</p> required <code>dr</code> <code>float</code> <p>The spatial step used in the simulation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array of stencil weights computed based on the provided parameters.</p>"},{"location":"api/Stim/","title":"Stim","text":"<p>Base class for stimulation in cardiac models.</p> <p>The <code>Stim</code> class represents a general stimulation object used in cardiac simulations. It provides methods to manage the timing and state of stimulation. Subclasses should implement specific stimulation behaviors.</p> <p>Attributes:</p> Name Type Description <code>t</code> <code>float</code> <p>The time at which the stimulation is to occur.</p> <code>passed</code> <code>bool</code> <p>A flag indicating whether the stimulation has been applied.</p> <p>Methods:</p> Name Description <code>stimulate</code> <p>Applies the stimulation to the provided model. This method should be implemented by subclasses.</p> <code>ready</code> <p>Prepares the stimulation for application. This method should be implemented by subclasses.</p> <code>done</code> <p>Marks the stimulation as completed. This method should be implemented by subclasses.</p>"},{"location":"api/Stim/#finitewave.core.stimulation.stim.Stim.__init__","title":"<code>__init__(time)</code>","text":"<p>Initializes the Stim object with the specified time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation is scheduled to occur.</p> required"},{"location":"api/Stim/#finitewave.core.stimulation.stim.Stim.done","title":"<code>done()</code>","text":"<p>Marks the stimulation as completed.</p> Notes <p>This is an abstract method that should be implemented by subclasses to define how the stimulation state is updated after application.</p>"},{"location":"api/Stim/#finitewave.core.stimulation.stim.Stim.ready","title":"<code>ready()</code>","text":"<p>Prepares the stimulation for application.</p> Notes <p>This is an abstract method that should be implemented by subclasses to define how the stimulation is prepared before being applied.</p>"},{"location":"api/Stim/#finitewave.core.stimulation.stim.Stim.stimulate","title":"<code>stimulate(model)</code>","text":"<p>Applies the stimulation to the provided model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>CardiacModel</code> <p>The simulation model to which the stimulation will be applied.</p> required Notes <p>This is an abstract method that should be implemented by subclasses to define specific stimulation behaviors.</p>"},{"location":"api/StimCurrent/","title":"StimCurrent","text":"<p>               Bases: <code>Stim</code></p> <p>A stimulation class that applies a current value to the cardiac model.</p> <p>This class represents a type of stimulation where a current is applied to the model for a specified duration. It extends the base <code>Stim</code> class and includes methods for preparing the stimulation and updating its status based on elapsed time.</p> <p>Attributes:</p> Name Type Description <code>curr_value</code> <code>float</code> <p>The current value to be applied during the stimulation.</p> <code>curr_time</code> <code>float</code> <p>The duration for which the current is applied.</p> <code>_acc_time</code> <code>float</code> <p>Accumulated time remaining for the current stimulation (used internally).</p> <code>_dt</code> <code>float</code> <p>Time step of the simulation (used internally).</p> <p>Methods:</p> Name Description <code>ready</code> <p>Prepares the stimulation by initializing accumulated time and setting the simulation time step.</p> <code>done</code> <p>Updates the stimulation status based on the elapsed time and marks the stimulation as completed if the current time has elapsed.</p>"},{"location":"api/StimCurrent/#finitewave.core.stimulation.stim_current.StimCurrent.__init__","title":"<code>__init__(time, curr_value, curr_time)</code>","text":"<p>Initializes the StimCurrent object with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the current stimulation is to start.</p> required <code>curr_value</code> <code>float</code> <p>The current value to be applied during the stimulation.</p> required <code>curr_time</code> <code>float</code> <p>The duration for which the current will be applied.</p> required"},{"location":"api/StimCurrent/#finitewave.core.stimulation.stim_current.StimCurrent.done","title":"<code>done()</code>","text":"<p>Updates the stimulation status based on the elapsed time.</p> <p>This method decreases the accumulated time by the simulation time step and checks if the current stimulation duration has elapsed. If the time has elapsed, the <code>passed</code> flag is set to <code>True</code>, indicating that the stimulation is completed.</p>"},{"location":"api/StimCurrent/#finitewave.core.stimulation.stim_current.StimCurrent.ready","title":"<code>ready(model)</code>","text":"<p>Prepares the stimulation for application.</p> <p>This method initializes the accumulated time with the current duration and sets the time step of the simulation. The <code>passed</code> flag is set to <code>False</code> indicating that the stimulation has not yet been applied.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>CardiacModel</code> <p>The simulation model to which the current stimulation will be applied.</p> required"},{"location":"api/StimCurrentCoord2D/","title":"StimCurrentCoord2D","text":"<p>               Bases: <code>StimCurrent</code></p> <p>A class that applies a stimulation current to a rectangular region of a 2D cardiac tissue model.</p> <p>Inherits from <code>StimCurrent</code>.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>curr_value</code> <code>float</code> <p>The value of the stimulation current.</p> required <code>curr_time</code> <code>float</code> <p>The duration of the stimulation.</p> required <code>x1</code> <code>int</code> <p>The x-coordinate of the lower-left corner of the rectangular region.</p> required <code>x2</code> <code>int</code> <p>The x-coordinate of the upper-right corner of the rectangular region.</p> required <code>y1</code> <code>int</code> <p>The y-coordinate of the lower-left corner of the rectangular region.</p> required <code>y2</code> <code>int</code> <p>The y-coordinate of the upper-right corner of the rectangular region.</p> required"},{"location":"api/StimCurrentCoord2D/#finitewave.cpuwave2D.stimulation.stim_current_coord_2d.StimCurrentCoord2D.__init__","title":"<code>__init__(time, curr_value, curr_time, x1, x2, y1, y2)</code>","text":"<p>Initializes the StimCurrentCoord2D instance.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>curr_value</code> <code>float</code> <p>The value of the stimulation current.</p> required <code>curr_time</code> <code>float</code> <p>The duration of the stimulation.</p> required <code>x1</code> <code>int</code> <p>The x-coordinate of the lower-left corner of the rectangular region.</p> required <code>x2</code> <code>int</code> <p>The x-coordinate of the upper-right corner of the rectangular region.</p> required <code>y1</code> <code>int</code> <p>The y-coordinate of the lower-left corner of the rectangular region.</p> required <code>y2</code> <code>int</code> <p>The y-coordinate of the upper-right corner of the rectangular region.</p> required"},{"location":"api/StimCurrentCoord2D/#finitewave.cpuwave2D.stimulation.stim_current_coord_2d.StimCurrentCoord2D.stimulate","title":"<code>stimulate(model)</code>","text":"<p>Applies the stimulation current to the specified rectangular region of the cardiac tissue model.</p> <p>The stimulation is applied only if the current time is within the stimulation period and the stimulation has not been previously applied.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model to which the stimulation current is applied. The model must have an attribute <code>cardiac_tissue</code> with a <code>mesh</code> property and an attribute <code>u</code> representing the state of the tissue.</p> required Notes <p>The stimulation is applied to the region of interest (ROI) defined by the coordinates (x1, x2) and (y1, y2). The current value is added to the <code>model.u</code> attribute, which represents the state of the tissue.</p>"},{"location":"api/StimCurrentCoord3D/","title":"StimCurrentCoord3D","text":"<p>               Bases: <code>StimCurrent</code></p> <p>A class that applies a stimulation current to a rectangular region of a 3D cardiac tissue model.</p> <p>Inherits from <code>StimCurrent</code>.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>curr_value</code> <code>float</code> <p>The value of the stimulation current.</p> required <code>curr_time</code> <code>float</code> <p>The duration of the stimulation.</p> required <code>x1</code> <code>int</code> <p>The x-coordinate of the lower-left corner of the rectangular region.</p> required <code>x2</code> <code>int</code> <p>The x-coordinate of the upper-right corner of the rectangular region.</p> required <code>y1</code> <code>int</code> <p>The y-coordinate of the lower-left corner of the rectangular region.</p> required <code>y2</code> <code>int</code> <p>The y-coordinate of the upper-right corner of the rectangular region.</p> required <code>z1</code> <code>int</code> <p>The z-coordinate of the lower-left corner of the rectangular region.</p> required <code>z2</code> <code>int</code> <p>The z-coordinate of the upper-right corner of the rectangular region.</p> required"},{"location":"api/StimCurrentCoord3D/#finitewave.cpuwave3D.stimulation.stim_current_coord_3d.StimCurrentCoord3D.__init__","title":"<code>__init__(time, curr_value, curr_time, x1, x2, y1, y2, z1, z2)</code>","text":"<p>Initializes the StimCurrentCoord3D instance.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>curr_value</code> <code>float</code> <p>The value of the stimulation current.</p> required <code>curr_time</code> <code>float</code> <p>The duration of the stimulation.</p> required <code>x1</code> <code>int</code> <p>The x-coordinate of the lower-left corner of the rectangular region.</p> required <code>x2</code> <code>int</code> <p>The x-coordinate of the upper-right corner of the rectangular region.</p> required <code>y1</code> <code>int</code> <p>The y-coordinate of the lower-left corner of the rectangular region.</p> required <code>y2</code> <code>int</code> <p>The y-coordinate of the upper-right corner of the rectangular region.</p> required <code>z1</code> <code>int</code> <p>The z-coordinate of the lower-left corner of the rectangular region.</p> required <code>z2</code> <code>int</code> <p>The z-coordinate of the upper-right corner of the rectangular region.</p> required"},{"location":"api/StimCurrentCoord3D/#finitewave.cpuwave3D.stimulation.stim_current_coord_3d.StimCurrentCoord3D.stimulate","title":"<code>stimulate(model)</code>","text":"<p>Applies the stimulation current to the specified rectangular region of the cardiac tissue model.</p> <p>The stimulation is applied only if the current time is within the stimulation period and the stimulation has not been previously applied.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model to which the stimulation current is applied. The model must have an attribute <code>cardiac_tissue</code> with a <code>mesh</code> property and an attribute <code>u</code> representing the state of the tissue.</p> required Notes <p>The stimulation is applied to the region of interest (ROI) defined by the coordinates (x1, x2), (y1, y2) and (z1, z2). The current value is added to the <code>model.u</code> attribute, which represents the state of the tissue.</p>"},{"location":"api/StimCurrentMatrix2D/","title":"StimCurrentMatrix2D","text":"<p>               Bases: <code>StimCurrent</code></p> <p>A class that applies a stimulation current to a 2D cardiac tissue model based on a binary matrix.</p> <p>Inherits from <code>StimCurrent</code>.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>curr_value</code> <code>float</code> <p>The value of the stimulation current.</p> required <code>curr_time</code> <code>float</code> <p>The duration of the stimulation.</p> required <code>matrix</code> <code>ndarray</code> <p>A 2D binary matrix indicating the region of interest for stimulation.  Elements greater than 0 represent regions to be stimulated.</p> required"},{"location":"api/StimCurrentMatrix2D/#finitewave.cpuwave2D.stimulation.stim_current_matrix_2d.StimCurrentMatrix2D.__init__","title":"<code>__init__(time, curr_value, curr_time, matrix)</code>","text":"<p>Initializes the StimCurrentMatrix2D instance.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>curr_value</code> <code>float</code> <p>The value of the stimulation current.</p> required <code>curr_time</code> <code>float</code> <p>The duration of the stimulation.</p> required <code>matrix</code> <code>ndarray</code> <p>A 2D binary matrix indicating the region of interest for stimulation.</p> required"},{"location":"api/StimCurrentMatrix2D/#finitewave.cpuwave2D.stimulation.stim_current_matrix_2d.StimCurrentMatrix2D.stimulate","title":"<code>stimulate(model)</code>","text":"<p>Applies the stimulation current to the cardiac tissue model based on the specified binary matrix.</p> <p>The stimulation is applied only if the current time is within the stimulation period and the stimulation has not been previously applied.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model to which the stimulation current is applied. The model must have an attribute <code>cardiac_tissue</code> with a <code>mesh</code> property and an attribute <code>u</code> representing the state of the tissue.</p> required Notes <p>The stimulation is applied to the regions of the cardiac tissue indicated by the matrix.  For each position where the matrix value is greater than 0 and the corresponding value  in the <code>model.cardiac_tissue.mesh</code> is 1, the current value is added to <code>model.u</code>.</p>"},{"location":"api/StimCurrentMatrix3D/","title":"StimCurrentMatrix3D","text":"<p>               Bases: <code>StimCurrent</code></p> <p>A class that applies a stimulation current to a 3D cardiac tissue model based on a binary matrix.</p> <p>Inherits from <code>StimCurrent</code>.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>curr_value</code> <code>float</code> <p>The value of the stimulation current.</p> required <code>curr_time</code> <code>float</code> <p>The duration of the stimulation.</p> required <code>matrix</code> <code>ndarray</code> <p>A 3D binary matrix indicating the region of interest for stimulation.  Elements greater than 0 represent regions to be stimulated.</p> required"},{"location":"api/StimCurrentMatrix3D/#finitewave.cpuwave3D.stimulation.stim_current_matrix_3d.StimCurrentMatrix3D.__init__","title":"<code>__init__(time, curr_value, curr_time, matrix)</code>","text":"<p>Initializes the StimCurrentMatrix3D instance.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>curr_value</code> <code>float</code> <p>The value of the stimulation current.</p> required <code>curr_time</code> <code>float</code> <p>The duration of the stimulation.</p> required <code>matrix</code> <code>ndarray</code> <p>A 3D binary matrix indicating the region of interest for stimulation.</p> required"},{"location":"api/StimCurrentMatrix3D/#finitewave.cpuwave3D.stimulation.stim_current_matrix_3d.StimCurrentMatrix3D.stimulate","title":"<code>stimulate(model)</code>","text":"<p>Applies the stimulation current to the cardiac tissue model based on the specified binary matrix.</p> <p>The stimulation is applied only if the current time is within the stimulation period and the stimulation has not been previously applied.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model to which the stimulation current is applied. The model must have an attribute <code>cardiac_tissue</code> with a <code>mesh</code> property and an attribute <code>u</code> representing the state of the tissue.</p> required Notes <p>The stimulation is applied to the regions of the cardiac tissue indicated by the matrix.  For each position where the matrix value is greater than 0 and the corresponding value  in the <code>model.cardiac_tissue.mesh</code> is 1, the current value is added to <code>model.u</code>.</p>"},{"location":"api/StimSequence/","title":"StimSequence","text":"<p>A sequence of stimuli to be applied to the cardiac model.</p> <p>This class manages a list of stimulation objects and applies them to the model based on the simulation time. It handles the initialization of stimuli, adding and removing stimuli, and applying the next set of stimuli in the sequence.</p> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>list</code> <p>A list of <code>Stim</code> objects representing the sequence of stimuli to be applied to the model.</p> <code>model</code> <code>(CardiacModel, optional)</code> <p>The cardiac model to which the stimuli will be applied. This is set during initialization.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Prepares each stimulus in the sequence for application based on the provided model.</p> <code>add_stim</code> <p>Adds a <code>Stim</code> object to the sequence of stimuli.</p> <code>remove_stim</code> <p>Clears the sequence of stimuli, removing all stimuli from the list.</p> <code>stimulate_next</code> <p>Applies the next set of stimuli based on the current time in the model.</p>"},{"location":"api/StimSequence/#finitewave.core.stimulation.stim_sequence.StimSequence.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the StimSequence object with an empty sequence and no associated model.</p>"},{"location":"api/StimSequence/#finitewave.core.stimulation.stim_sequence.StimSequence.add_stim","title":"<code>add_stim(stim)</code>","text":"<p>Adds a stimulus to the sequence.</p> <p>Parameters:</p> Name Type Description Default <code>stim</code> <code>Stim</code> <p>The <code>Stim</code> object to be added to the sequence.</p> required"},{"location":"api/StimSequence/#finitewave.core.stimulation.stim_sequence.StimSequence.initialize","title":"<code>initialize(model)</code>","text":"<p>Prepares each stimulus in the sequence for application.</p> <p>This method sets up each stimulus based on the provided model, ensuring that each stimulus is ready to be applied according to its specified start time.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>CardiacModel</code> <p>The simulation model that will be used to prepare the stimuli.</p> required"},{"location":"api/StimSequence/#finitewave.core.stimulation.stim_sequence.StimSequence.remove_stim","title":"<code>remove_stim()</code>","text":"<p>Removes all stimuli from the sequence.</p> <p>This method clears the sequence, effectively removing all stimuli that were previously added.</p>"},{"location":"api/StimSequence/#finitewave.core.stimulation.stim_sequence.StimSequence.stimulate_next","title":"<code>stimulate_next()</code>","text":"<p>Applies the next set of stimuli based on the current time in the model.</p> <p>This method checks each stimulus in the sequence to determine if it should be applied based on the current simulation time. If a stimulus is due to be applied and has not yet been marked as passed, it is stimulated and then marked as done.</p>"},{"location":"api/StimVoltage/","title":"StimVoltage","text":"<p>               Bases: <code>Stim</code></p> <p>A stimulation class that sets a voltage value in the cardiac model.</p> <p>This class represents a specific type of stimulation where a voltage value is applied to the model at a specified time. It extends the base <code>Stim</code> class and provides functionality for managing the stimulation process, including preparing and finalizing the stimulation.</p> <p>Attributes:</p> Name Type Description <code>volt_value</code> <code>float</code> <p>The voltage value to be applied during the stimulation.</p> <p>Methods:</p> Name Description <code>ready</code> <p>Prepares the stimulation for application at the specified time.</p> <code>done</code> <p>Marks the stimulation as completed.</p>"},{"location":"api/StimVoltage/#finitewave.core.stimulation.stim_voltage.StimVoltage.__init__","title":"<code>__init__(time, volt_value)</code>","text":"<p>Initializes the StimVoltage object with the specified time and voltage value.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the voltage stimulation is to occur.</p> required <code>volt_value</code> <code>float</code> <p>The voltage value to be applied during the stimulation.</p> required"},{"location":"api/StimVoltage/#finitewave.core.stimulation.stim_voltage.StimVoltage.done","title":"<code>done()</code>","text":"<p>Marks the stimulation as completed.</p> <p>This method sets the <code>passed</code> flag to <code>True</code>, indicating that the stimulation has been applied.</p>"},{"location":"api/StimVoltage/#finitewave.core.stimulation.stim_voltage.StimVoltage.ready","title":"<code>ready(model)</code>","text":"<p>Prepares the stimulation for application.</p> <p>This method sets the <code>passed</code> flag to <code>False</code>, indicating that the stimulation has not yet been applied.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>CardiacModel</code> <p>The simulation model to which the voltage stimulation will be applied.</p> required"},{"location":"api/StimVoltageCoord2D/","title":"StimVoltageCoord2D","text":"<p>               Bases: <code>StimVoltage</code></p> <p>A class that applies a voltage stimulus to a 2D cardiac tissue model within a specified region of interest.</p> <p>Inherits from <code>StimVoltage</code>.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>volt_value</code> <code>float</code> <p>The voltage value to apply to the region of interest.</p> required <code>x1</code> <code>int</code> <p>The starting x-coordinate of the region of interest.</p> required <code>x2</code> <code>int</code> <p>The ending x-coordinate of the region of interest.</p> required <code>y1</code> <code>int</code> <p>The starting y-coordinate of the region of interest.</p> required <code>y2</code> <code>int</code> <p>The ending y-coordinate of the region of interest.</p> required"},{"location":"api/StimVoltageCoord2D/#finitewave.cpuwave2D.stimulation.stim_voltage_coord_2d.StimVoltageCoord2D.__init__","title":"<code>__init__(time, volt_value, x1, x2, y1, y2)</code>","text":"<p>Initializes the StimVoltageCoord2D instance.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>volt_value</code> <code>float</code> <p>The voltage value to apply.</p> required <code>x1</code> <code>int</code> <p>The starting x-coordinate of the region of interest.</p> required <code>x2</code> <code>int</code> <p>The ending x-coordinate of the region of interest.</p> required <code>y1</code> <code>int</code> <p>The starting y-coordinate of the region of interest.</p> required <code>y2</code> <code>int</code> <p>The ending y-coordinate of the region of interest.</p> required"},{"location":"api/StimVoltageCoord2D/#finitewave.cpuwave2D.stimulation.stim_voltage_coord_2d.StimVoltageCoord2D.stimulate","title":"<code>stimulate(model)</code>","text":"<p>Applies the voltage stimulus to the cardiac tissue model within the specified region of interest.</p> <p>The voltage is applied only if the current time is within the stimulation period and the stimulation has not been previously applied.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model to which the voltage stimulus is applied. The model must have an attribute <code>cardiac_tissue</code> with a <code>mesh</code> property and an attribute <code>u</code> representing the state of the tissue.</p> required Notes <p>The voltage value is applied to the region of the cardiac tissue specified by the coordinates (x1, x2) and (y1, y2). The <code>model.cardiac_tissue.mesh</code> is used to mask the regions where the voltage should be applied. Only positions where the mesh value is 1 will be updated.</p>"},{"location":"api/StimVoltageCoord3D/","title":"StimVoltageCoord3D","text":"<p>               Bases: <code>StimVoltage</code></p> <p>A class that applies a voltage stimulus to a 3D cardiac tissue model within a specified region of interest.</p> <p>Inherits from <code>StimVoltage</code>.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>volt_value</code> <code>float</code> <p>The voltage value to apply to the region of interest.</p> required <code>x1</code> <code>int</code> <p>The starting x-coordinate of the region of interest.</p> required <code>x2</code> <code>int</code> <p>The ending x-coordinate of the region of interest.</p> required <code>y1</code> <code>int</code> <p>The starting y-coordinate of the region of interest.</p> required <code>y2</code> <code>int</code> <p>The ending y-coordinate of the region of interest.</p> required <code>z1</code> <code>int</code> <p>The starting z-coordinate of the region of interest.</p> required <code>z2</code> <code>int</code> <p>The ending z-coordinate of the region of interest.</p> required"},{"location":"api/StimVoltageCoord3D/#finitewave.cpuwave3D.stimulation.stim_voltage_coord_3d.StimVoltageCoord3D.__init__","title":"<code>__init__(time, volt_value, x1, x2, y1, y2, z1, z2)</code>","text":"<p>Initializes the StimVoltageCoord2D instance.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>volt_value</code> <code>float</code> <p>The voltage value to apply.</p> required <code>x1</code> <code>int</code> <p>The starting x-coordinate of the region of interest.</p> required <code>x2</code> <code>int</code> <p>The ending x-coordinate of the region of interest.</p> required <code>y1</code> <code>int</code> <p>The starting y-coordinate of the region of interest.</p> required <code>y2</code> <code>int</code> <p>The ending y-coordinate of the region of interest.</p> required <code>z1</code> <code>int</code> <p>The starting z-coordinate of the region of interest.</p> required <code>z2</code> <code>int</code> <p>The ending z-coordinate of the region of interest.</p> required"},{"location":"api/StimVoltageCoord3D/#finitewave.cpuwave3D.stimulation.stim_voltage_coord_3d.StimVoltageCoord3D.stimulate","title":"<code>stimulate(model)</code>","text":"<p>Applies the voltage stimulus to the cardiac tissue model within the specified region of interest.</p> <p>The voltage is applied only if the current time is within the stimulation period and the stimulation has not been previously applied.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model to which the voltage stimulus is applied. The model must have an attribute <code>cardiac_tissue</code> with a <code>mesh</code> property and an attribute <code>u</code> representing the state of the tissue.</p> required Notes <p>The voltage value is applied to the region of the cardiac tissue specified by the coordinates (x1, x2), (y1, y2) and (z1, z2). The <code>model.cardiac_tissue.mesh</code> is used to mask the regions where the voltage should be applied. Only positions where the mesh value is 1 will be updated.</p>"},{"location":"api/StimVoltageMatrix2D/","title":"StimVoltageMatrix2D","text":"<p>               Bases: <code>StimVoltage</code></p> <p>A class that applies a voltage stimulus to a 2D cardiac tissue model according to a specified matrix.</p> <p>Inherits from <code>StimVoltage</code>.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>volt_value</code> <code>float</code> <p>The voltage value to apply.</p> required <code>matrix</code> <code>ndarray</code> <p>A 2D array where the voltage stimulus is applied to locations with values greater than 0.</p> required"},{"location":"api/StimVoltageMatrix2D/#finitewave.cpuwave2D.stimulation.stim_voltage_matrix_2d.StimVoltageMatrix2D.__init__","title":"<code>__init__(time, volt_value, matrix)</code>","text":"<p>Initializes the StimVoltageMatrix2D instance.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>volt_value</code> <code>float</code> <p>The voltage value to apply.</p> required <code>matrix</code> <code>ndarray</code> <p>A 2D array where the voltage stimulus is applied to locations with values greater than 0.</p> required"},{"location":"api/StimVoltageMatrix2D/#finitewave.cpuwave2D.stimulation.stim_voltage_matrix_2d.StimVoltageMatrix2D.stimulate","title":"<code>stimulate(model)</code>","text":"<p>Applies the voltage stimulus to the cardiac tissue model based on the specified matrix.</p> <p>The voltage is applied only if the current time is within the stimulation period and the stimulation has not been previously applied.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model to which the voltage stimulus is applied. The model must have an attribute <code>cardiac_tissue</code> with a <code>mesh</code> property and an attribute <code>u</code> representing the state of the tissue.</p> required Notes <p>The voltage value is applied to the positions in the cardiac tissue where the corresponding value in <code>matrix</code> is greater than 0, and the <code>model.cardiac_tissue.mesh</code> value is 1.</p>"},{"location":"api/StimVoltageMatrix3D/","title":"StimVoltageMatrix3D","text":"<p>               Bases: <code>StimVoltage</code></p> <p>A class that applies a voltage stimulus to a 3D cardiac tissue model according to a specified matrix.</p> <p>Inherits from <code>StimVoltage</code>.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>volt_value</code> <code>float</code> <p>The voltage value to apply.</p> required <code>matrix</code> <code>ndarray</code> <p>A 3D array where the voltage stimulus is applied to locations with values greater than 0.</p> required"},{"location":"api/StimVoltageMatrix3D/#finitewave.cpuwave3D.stimulation.stim_voltage_matrix_3d.StimVoltageMatrix3D.__init__","title":"<code>__init__(time, volt_value, matrix)</code>","text":"<p>Initializes the StimVoltageMatrix3D instance.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which the stimulation starts.</p> required <code>volt_value</code> <code>float</code> <p>The voltage value to apply.</p> required <code>matrix</code> <code>ndarray</code> <p>A 3D array where the voltage stimulus is applied to locations with values greater than 0.</p> required"},{"location":"api/StimVoltageMatrix3D/#finitewave.cpuwave3D.stimulation.stim_voltage_matrix_3d.StimVoltageMatrix3D.stimulate","title":"<code>stimulate(model)</code>","text":"<p>Applies the voltage stimulus to the cardiac tissue model based on the specified matrix.</p> <p>The voltage is applied only if the current time is within the stimulation period and the stimulation has not been previously applied.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The cardiac tissue model to which the voltage stimulus is applied. The model must have an attribute <code>cardiac_tissue</code> with a <code>mesh</code> property and an attribute <code>u</code> representing the state of the tissue.</p> required Notes <p>The voltage value is applied to the positions in the cardiac tissue where the corresponding value in <code>matrix</code> is greater than 0, and the <code>model.cardiac_tissue.mesh</code> value is 1.</p>"},{"location":"api/Structural2DPattern/","title":"Structural2DPattern","text":"<p>               Bases: <code>FibrosisPattern</code></p> <p>Class for generating a structural fibrosis pattern in a 2D mesh.</p> <p>The pattern consists of rectangular blocks distributed throughout a specified region of the mesh, with the density controlling the likelihood of each block being present.</p> <p>Attributes:</p> Name Type Description <code>x1</code> <code>int</code> <p>The starting x-coordinate of the area where blocks can be placed.</p> <code>x2</code> <code>int</code> <p>The ending x-coordinate of the area where blocks can be placed.</p> <code>y1</code> <code>int</code> <p>The starting y-coordinate of the area where blocks can be placed.</p> <code>y2</code> <code>int</code> <p>The ending y-coordinate of the area where blocks can be placed.</p> <code>dens</code> <code>float</code> <p>The density of the fibrosis blocks, represented as a probability.</p> <code>length_i</code> <code>int</code> <p>The width of each block.</p> <code>length_j</code> <code>int</code> <p>The height of each block.</p> <p>Methods:</p> Name Description <code>generate</code> <p>Generates and applies a structural fibrosis pattern to the mesh. If no mesh is provided,  a new mesh is created with the given size.</p>"},{"location":"api/Structural2DPattern/#finitewave.cpuwave2D.fibrosis.structural_2d_pattern.Structural2DPattern.__init__","title":"<code>__init__(x1, x2, y1, y2, dens, length_i, length_j)</code>","text":"<p>Initializes the Structural2DPattern with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>int</code> <p>The starting x-coordinate of the area where blocks can be placed.</p> required <code>x2</code> <code>int</code> <p>The ending x-coordinate of the area where blocks can be placed.</p> required <code>y1</code> <code>int</code> <p>The starting y-coordinate of the area where blocks can be placed.</p> required <code>y2</code> <code>int</code> <p>The ending y-coordinate of the area where blocks can be placed.</p> required <code>dens</code> <code>float</code> <p>The density of the fibrosis blocks, represented as a probability.</p> required <code>length_i</code> <code>int</code> <p>The width of each block.</p> required <code>length_j</code> <code>int</code> <p>The height of each block.</p> required"},{"location":"api/Structural2DPattern/#finitewave.cpuwave2D.fibrosis.structural_2d_pattern.Structural2DPattern.generate","title":"<code>generate(size, mesh=None)</code>","text":"<p>Generates and applies a structural fibrosis pattern to the mesh.</p> <p>The mesh is divided into blocks of size <code>length_i</code> by <code>length_j</code>, with each block having  a probability <code>dens</code> of being filled with fibrosis. The function ensures that blocks do not extend beyond the specified region.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>tuple of int</code> <p>The size of the mesh to create if no mesh is provided.</p> required <code>mesh</code> <code>ndarray</code> <p>The mesh to which the fibrosis pattern is applied. If None, a new mesh is created  with the given size.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The mesh with the applied structural fibrosis pattern.</p>"},{"location":"api/Structural3DPattern/","title":"Structural3DPattern","text":"<p>               Bases: <code>FibrosisPattern</code></p> <p>A class to generate a structural fibrosis pattern in a 3D mesh grid.</p> <p>Attributes:</p> Name Type Description <code>x1, x2</code> <code>int</code> <p>The start and end indices for the region of interest along the x-axis.</p> <code>y1, y2</code> <code>int</code> <p>The start and end indices for the region of interest along the y-axis.</p> <code>z1, z2</code> <code>int</code> <p>The start and end indices for the region of interest along the z-axis.</p> <code>dens</code> <code>float</code> <p>The density of fibrosis within the specified region, ranging from 0 (no fibrosis) to 1 (full fibrosis).</p> <code>length_i, length_j, length_k</code> <code>int</code> <p>The lengths of fibrosis blocks along each axis (x, y, z).</p> <p>Methods:</p> Name Description <code>generate</code> <p>Generates a 3D mesh with a structural fibrosis pattern within the specified region.</p>"},{"location":"api/Structural3DPattern/#finitewave.cpuwave3D.fibrosis.structural_3d_pattern.Structural3DPattern.__init__","title":"<code>__init__(x1, x2, y1, y2, z1, z2, dens, length_i, length_j, length_k)</code>","text":"<p>Initializes the Structural3DPattern object with the given region of interest, density, and block sizes.</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>int</code> <p>The start and end indices for the region of interest along the x-axis.</p> required <code>x2</code> <code>int</code> <p>The start and end indices for the region of interest along the x-axis.</p> required <code>y1</code> <code>int</code> <p>The start and end indices for the region of interest along the y-axis.</p> required <code>y2</code> <code>int</code> <p>The start and end indices for the region of interest along the y-axis.</p> required <code>z1</code> <code>int</code> <p>The start and end indices for the region of interest along the z-axis.</p> required <code>z2</code> <code>int</code> <p>The start and end indices for the region of interest along the z-axis.</p> required <code>dens</code> <code>float</code> <p>The density of fibrosis within the specified region.</p> required <code>length_i</code> <code>int</code> <p>The lengths of fibrosis blocks along each axis (x, y, z).</p> required <code>length_j</code> <code>int</code> <p>The lengths of fibrosis blocks along each axis (x, y, z).</p> required <code>length_k</code> <code>int</code> <p>The lengths of fibrosis blocks along each axis (x, y, z).</p> required"},{"location":"api/Structural3DPattern/#finitewave.cpuwave3D.fibrosis.structural_3d_pattern.Structural3DPattern.generate","title":"<code>generate(size, mesh=None)</code>","text":"<p>Generates a 3D mesh with a structural fibrosis pattern within the specified region.</p> <p>If a mesh is provided, the pattern is applied to the existing mesh; otherwise, a new mesh is created.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>tuple of int</code> <p>The size of the 3D mesh grid (x, y, z).</p> required <code>mesh</code> <code>ndarray</code> <p>A 3D NumPy array representing the existing mesh grid to which the fibrosis pattern will be applied. If None, a new mesh grid of the given size is created.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A 3D NumPy array of the same size as the input, with the structural fibrosis pattern applied.</p>"},{"location":"api/TP062D/","title":"TP062D","text":"<p>               Bases: <code>CardiacModel</code></p> <p>A class to represent the TP06 cardiac model in 2D.</p> Inherits from: <p>CardiacModel     Base class for cardiac models.</p> <p>Attributes:</p> Name Type Description <code>m</code> <code>ndarray</code> <p>Array for the gating variable m.</p> <code>h</code> <code>ndarray</code> <p>Array for the gating variable h.</p> <code>j_</code> <code>ndarray</code> <p>Array for the gating variable j_.</p> <code>d</code> <code>ndarray</code> <p>Array for the gating variable d.</p> <code>f</code> <code>ndarray</code> <p>Array for the gating variable f.</p> <code>x</code> <code>ndarray</code> <p>Array for the gating variable x.</p> <code>Cai_c</code> <code>ndarray</code> <p>Array for the concentration of calcium in the intracellular space.</p> <code>model_parameters</code> <code>dict</code> <p>Dictionary to hold model parameters.</p> <code>state_vars</code> <code>list of str</code> <p>List of state variable names.</p> <code>npfloat</code> <code>str</code> <p>Data type used for floating point operations.</p> <code>diffuse_kernel</code> <code>function</code> <p>Function to handle diffusion in the model.</p> <code>ionic_kernel</code> <code>function</code> <p>Function to handle ionic currents in the model.</p> <code>u</code> <code>ndarray</code> <p>Array for membrane potential.</p> <code>u_new</code> <code>ndarray</code> <p>Array for updated membrane potential.</p> <code>Cai</code> <code>ndarray</code> <p>Array for calcium concentration in the intracellular space.</p> <code>CaSR</code> <code>ndarray</code> <p>Array for calcium concentration in the sarcoplasmic reticulum.</p> <code>CaSS</code> <code>ndarray</code> <p>Array for calcium concentration in the subsarcolemmal space.</p> <code>Nai</code> <code>ndarray</code> <p>Array for sodium concentration in the intracellular space.</p> <code>Ki</code> <code>ndarray</code> <p>Array for potassium concentration in the intracellular space.</p> <code>M_</code> <code>ndarray</code> <p>Array for gating variable M_.</p> <code>H_</code> <code>ndarray</code> <p>Array for gating variable H_.</p> <code>J_</code> <code>ndarray</code> <p>Array for gating variable J_.</p> <code>Xr1</code> <code>ndarray</code> <p>Array for gating variable Xr1.</p> <code>Xr2</code> <code>ndarray</code> <p>Array for gating variable Xr2.</p> <code>Xs</code> <code>ndarray</code> <p>Array for gating variable Xs.</p> <code>R_</code> <code>ndarray</code> <p>Array for gating variable R_.</p> <code>S_</code> <code>ndarray</code> <p>Array for gating variable S_.</p> <code>D_</code> <code>ndarray</code> <p>Array for gating variable D_.</p> <code>F_</code> <code>ndarray</code> <p>Array for gating variable F_.</p> <code>F2_</code> <code>ndarray</code> <p>Array for gating variable F2_.</p> <code>FCass</code> <code>ndarray</code> <p>Array for calcium concentration in the sarcoplasmic reticulum.</p> <code>RR</code> <code>ndarray</code> <p>Array for calcium release from the sarcoplasmic reticulum.</p> <code>OO</code> <code>ndarray</code> <p>Array for open states of ryanodine receptors.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the model's state variables and kernels.</p> <code>run_ionic_kernel</code> <p>Executes the ionic kernel function to update ionic currents and state variables.</p>"},{"location":"api/TP062D/#finitewave.cpuwave2D.model.tp06_2d.tp06_2d.TP062D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the TP062D cardiac model.</p> <p>Sets up the arrays for state variables and model parameters.</p>"},{"location":"api/TP062D/#finitewave.cpuwave2D.model.tp06_2d.tp06_2d.TP062D.initialize","title":"<code>initialize()</code>","text":"<p>Initializes the model's state variables and diffusion/ionic kernels.</p> <p>Sets up the initial values for membrane potential, ion concentrations, gating variables, and assigns the appropriate kernel functions.</p>"},{"location":"api/TP062D/#finitewave.cpuwave2D.model.tp06_2d.tp06_2d.TP062D.run_ionic_kernel","title":"<code>run_ionic_kernel()</code>","text":"<p>Executes the ionic kernel function to update ionic currents and state variables.</p> <p>This method calls the <code>ionic_kernel</code> function from the TP06Kernels2D class, passing in the current state of the model and the time step.</p>"},{"location":"api/TP063D/","title":"TP063D","text":"<p>               Bases: <code>CardiacModel</code></p> <p>A class to represent the TP06 cardiac model in 3D.</p> Inherits from: <p>CardiacModel     Base class for cardiac models.</p> <p>Attributes:</p> Name Type Description <code>m</code> <code>ndarray</code> <p>Array for the gating variable m.</p> <code>h</code> <code>ndarray</code> <p>Array for the gating variable h.</p> <code>j_</code> <code>ndarray</code> <p>Array for the gating variable j_.</p> <code>d</code> <code>ndarray</code> <p>Array for the gating variable d.</p> <code>f</code> <code>ndarray</code> <p>Array for the gating variable f.</p> <code>x</code> <code>ndarray</code> <p>Array for the gating variable x.</p> <code>Cai_c</code> <code>ndarray</code> <p>Array for the concentration of calcium in the intracellular space.</p> <code>model_parameters</code> <code>dict</code> <p>Dictionary to hold model parameters.</p> <code>state_vars</code> <code>list of str</code> <p>List of state variable names.</p> <code>npfloat</code> <code>str</code> <p>Data type used for floating point operations.</p> <code>diffuse_kernel</code> <code>function</code> <p>Function to handle diffusion in the model.</p> <code>ionic_kernel</code> <code>function</code> <p>Function to handle ionic currents in the model.</p> <code>u</code> <code>ndarray</code> <p>Array for membrane potential.</p> <code>u_new</code> <code>ndarray</code> <p>Array for updated membrane potential.</p> <code>Cai</code> <code>ndarray</code> <p>Array for calcium concentration in the intracellular space.</p> <code>CaSR</code> <code>ndarray</code> <p>Array for calcium concentration in the sarcoplasmic reticulum.</p> <code>CaSS</code> <code>ndarray</code> <p>Array for calcium concentration in the subsarcolemmal space.</p> <code>Nai</code> <code>ndarray</code> <p>Array for sodium concentration in the intracellular space.</p> <code>Ki</code> <code>ndarray</code> <p>Array for potassium concentration in the intracellular space.</p> <code>M_</code> <code>ndarray</code> <p>Array for gating variable M_.</p> <code>H_</code> <code>ndarray</code> <p>Array for gating variable H_.</p> <code>J_</code> <code>ndarray</code> <p>Array for gating variable J_.</p> <code>Xr1</code> <code>ndarray</code> <p>Array for gating variable Xr1.</p> <code>Xr2</code> <code>ndarray</code> <p>Array for gating variable Xr2.</p> <code>Xs</code> <code>ndarray</code> <p>Array for gating variable Xs.</p> <code>R_</code> <code>ndarray</code> <p>Array for gating variable R_.</p> <code>S_</code> <code>ndarray</code> <p>Array for gating variable S_.</p> <code>D_</code> <code>ndarray</code> <p>Array for gating variable D_.</p> <code>F_</code> <code>ndarray</code> <p>Array for gating variable F_.</p> <code>F2_</code> <code>ndarray</code> <p>Array for gating variable F2_.</p> <code>FCass</code> <code>ndarray</code> <p>Array for calcium concentration in the sarcoplasmic reticulum.</p> <code>RR</code> <code>ndarray</code> <p>Array for calcium release from the sarcoplasmic reticulum.</p> <code>OO</code> <code>ndarray</code> <p>Array for open states of ryanodine receptors.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes the model's state variables and kernels.</p> <code>run_ionic_kernel</code> <p>Executes the ionic kernel function to update ionic currents and state variables.</p>"},{"location":"api/TP063D/#finitewave.cpuwave3D.model.tp06_3d.tp06_3d.TP063D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the TP063D cardiac model.</p> <p>Sets up the arrays for state variables and model parameters.</p>"},{"location":"api/TP063D/#finitewave.cpuwave3D.model.tp06_3d.tp06_3d.TP063D.initialize","title":"<code>initialize()</code>","text":"<p>Initializes the model's state variables and diffusion/ionic kernels.</p> <p>Sets up the initial values for membrane potential, ion concentrations, gating variables, and assigns the appropriate kernel functions.</p>"},{"location":"api/TP063D/#finitewave.cpuwave3D.model.tp06_3d.tp06_3d.TP063D.run_ionic_kernel","title":"<code>run_ionic_kernel()</code>","text":"<p>Executes the ionic kernel function to update ionic currents and state variables.</p> <p>This method calls the <code>ionic_kernel</code> function from the TP06Kernels3D class, passing in the current state of the model and the time step.</p>"},{"location":"api/TP06Kernels2D/","title":"TP06Kernels2D","text":"<p>A class to manage the kernel functions for the TP06 cardiac model in 2D.</p> <p>Attributes:</p> Name Type Description <code>None</code> <p>Methods:</p> Name Description <code>get_diffuse_kernel</code> <p>Returns the appropriate diffusion kernel function based on the shape of the weights.</p> <code>get_ionic_kernel</code> <p>Returns the ionic kernel function for the TP06 model.</p>"},{"location":"api/TP06Kernels2D/#finitewave.cpuwave2D.model.tp06_2d.tp06_kernels_2d.TP06Kernels2D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the TP06Kernels2D class.</p>"},{"location":"api/TP06Kernels2D/#finitewave.cpuwave2D.model.tp06_2d.tp06_kernels_2d.TP06Kernels2D.get_diffuse_kernel","title":"<code>get_diffuse_kernel(shape)</code>  <code>staticmethod</code>","text":"<p>Returns the diffusion kernel function based on the shape of the weights.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple</code> <p>The shape of the weights array.</p> required <p>Returns:</p> Type Description <code>function</code> <p>The diffusion kernel function suitable for the given weight shape.</p> <p>Raises:</p> Type Description <code>IncorrectWeightsShapeError</code> <p>If the shape of the weights does not match expected values (5 or 9).</p>"},{"location":"api/TP06Kernels2D/#finitewave.cpuwave2D.model.tp06_2d.tp06_kernels_2d.TP06Kernels2D.get_ionic_kernel","title":"<code>get_ionic_kernel()</code>  <code>staticmethod</code>","text":"<p>Returns the ionic kernel function for the TP06 cardiac model.</p> <p>Returns:</p> Type Description <code>function</code> <p>The ionic kernel function for the TP06 model.</p>"},{"location":"api/TP06Kernels3D/","title":"TP06Kernels3D","text":"<p>A class to manage the kernel functions for the TP06 cardiac model in 3D.</p> <p>Attributes:</p> Name Type Description <code>None</code> <p>Methods:</p> Name Description <code>get_diffuse_kernel</code> <p>Returns the appropriate diffusion kernel function based on the shape of the weights.</p> <code>get_ionic_kernel</code> <p>Returns the ionic kernel function for the TP06 model.</p>"},{"location":"api/TP06Kernels3D/#finitewave.cpuwave3D.model.tp06_3d.tp06_kernels_3d.TP06Kernels3D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the TP06Kernels3D class.</p>"},{"location":"api/TP06Kernels3D/#finitewave.cpuwave3D.model.tp06_3d.tp06_kernels_3d.TP06Kernels3D.get_diffuse_kernel","title":"<code>get_diffuse_kernel(shape)</code>  <code>staticmethod</code>","text":"<p>Returns the diffusion kernel function based on the shape of the weights.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple</code> <p>The shape of the weights array.</p> required <p>Returns:</p> Type Description <code>function</code> <p>The diffusion kernel function suitable for the given weight shape.</p> <p>Raises:</p> Type Description <code>IncorrectWeightsShapeError</code> <p>If the shape of the weights does not match expected values (7 or 19).</p>"},{"location":"api/TP06Kernels3D/#finitewave.cpuwave3D.model.tp06_3d.tp06_kernels_3d.TP06Kernels3D.get_ionic_kernel","title":"<code>get_ionic_kernel()</code>  <code>staticmethod</code>","text":"<p>Returns the ionic kernel function for the TP06 cardiac model.</p> <p>Returns:</p> Type Description <code>function</code> <p>The ionic kernel function for the TP06 model.</p>"},{"location":"api/Tracker/","title":"Tracker","text":"<p>Base class for trackers used in simulations.</p> <p>This class provides a base implementation for trackers that monitor and record various aspects of the simulation. Trackers can be used to gather data such as activation times, wave dynamics, or ECG readings.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>CardiacModel</code> <p>The simulation model to which the tracker is attached. This allows the tracker to access the model's state and data during the simulation.</p> <code>file_name</code> <code>str</code> <p>The name of the file where the tracked data will be saved. Default is an empty string.</p> <code>path</code> <code>str</code> <p>The directory path where the tracked data will be saved. Default is the current directory.</p> <code>start_time</code> <code>float</code> <p>The time step at which tracking will begin. Default is 0.</p> <code>end_time</code> <code>float</code> <p>The time step at which tracking will end. Default is infinity.</p> <code>step</code> <code>int</code> <p>The frequency at which tracking will occur. Default is 1.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Abstract method to be implemented by subclasses for initializing the tracker with the simulation model.</p> <code>track</code> <p>Abstract method to be implemented by subclasses for tracking and recording data during the simulation.</p> <code>clone</code> <p>Creates a deep copy of the current tracker instance.</p> <code>write</code> <p>Abstract method to be implemented by subclasses for writing the tracked data to a file.</p>"},{"location":"api/Tracker/#finitewave.core.tracker.tracker.Tracker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Tracker instance with default attributes.</p>"},{"location":"api/Tracker/#finitewave.core.tracker.tracker.Tracker.clone","title":"<code>clone()</code>","text":"<p>Creates a deep copy of the current tracker instance.</p> <p>Returns:</p> Type Description <code>Tracker</code> <p>A deep copy of the current Tracker instance.</p>"},{"location":"api/Tracker/#finitewave.core.tracker.tracker.Tracker.initialize","title":"<code>initialize(model)</code>  <code>abstractmethod</code>","text":"<p>Abstract method to be implemented by subclasses for initializing the tracker with the simulation model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>CardiacModel</code> <p>The simulation model to which the tracker will be attached.</p> required"},{"location":"api/Tracker/#finitewave.core.tracker.tracker.Tracker.track","title":"<code>track()</code>","text":"<p>Tracks and records data during the simulation.</p> <p>This method should be called at each time step of the simulation.</p>"},{"location":"api/Tracker/#finitewave.core.tracker.tracker.Tracker.write","title":"<code>write()</code>","text":"<p>Writes the tracked data to a file.</p>"},{"location":"api/TrackerSequence/","title":"TrackerSequence","text":"<p>Manages a sequence of trackers for a simulation.</p> <p>The <code>TrackerSequence</code> class allows for the management of multiple <code>Tracker</code> instances. It provides methods to initialize trackers, add or remove trackers from the sequence, and iterate over the trackers to perform their tracking functions.</p> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>list of Tracker</code> <p>List containing the trackers in the sequence. The trackers are executed in the order they are added.</p> <code>model</code> <code>CardiacModel or None</code> <p>The simulation model to which the trackers are attached. It is set during initialization.</p> <p>Methods:</p> Name Description <code>initialize</code> <p>Initializes all trackers in the sequence with the provided simulation model.</p> <code>add_tracker</code> <p>Adds a new tracker to the end of the sequence.</p> <code>remove_trackers</code> <p>Removes all trackers from the sequence.</p> <code>tracker_next</code> <p>Executes the <code>track</code> method of each tracker in the sequence.</p>"},{"location":"api/TrackerSequence/#finitewave.core.tracker.tracker_sequence.TrackerSequence.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the TrackerSequence with an empty sequence and no model.</p>"},{"location":"api/TrackerSequence/#finitewave.core.tracker.tracker_sequence.TrackerSequence.add_tracker","title":"<code>add_tracker(tracker)</code>","text":"<p>Adds a new tracker to the end of the sequence.</p> <p>Parameters:</p> Name Type Description Default <code>tracker</code> <code>Tracker</code> <p>The tracker instance to be added to the sequence.</p> required"},{"location":"api/TrackerSequence/#finitewave.core.tracker.tracker_sequence.TrackerSequence.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes all trackers in the sequence with the provided simulation model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>CardiacModel</code> <p>The simulation model to which the trackers will be attached.</p> required"},{"location":"api/TrackerSequence/#finitewave.core.tracker.tracker_sequence.TrackerSequence.remove_trackers","title":"<code>remove_trackers()</code>","text":"<p>Removes all trackers from the sequence.</p>"},{"location":"api/TrackerSequence/#finitewave.core.tracker.tracker_sequence.TrackerSequence.tracker_next","title":"<code>tracker_next()</code>","text":"<p>Executes the <code>track</code> method of each tracker in the sequence.</p>"},{"location":"api/VTKFrame3DTracker/","title":"VTKFrame3DTracker","text":"<p>               Bases: <code>Tracker</code></p> <p>A class for tracking and saving VTK frames in a 3D model.</p> <p>Attributes:     step (int): The step size for tracking frames.     file_name (str): The name of the file to save the frames                      \".vtk\" or \".vtu\"     target_array (str): The name of the target array to be tracked.     file_type (str): The file type of the saved frames.</p>"},{"location":"api/VTKMeshBuilder/","title":"VTKMeshBuilder","text":""},{"location":"api/Variable2DTracker/","title":"Variable2DTracker","text":"<p>               Bases: <code>Tracker</code></p> <p>A tracker that records the values of specified variables from a 2D model  over time at a given grid point.</p> <p>Parameters:</p> Name Type Description Default <code>var_list</code> <code>list of str</code> <p>List of variable names to be tracked.</p> required <code>cell_ind</code> <code>list of int</code> <p>Indices of the cell to track. Default is [1, 1].</p> required <code>dir_name</code> <code>str</code> <p>Directory name where the data will be saved. Default is \"multi_vars\".</p> required <code>vars</code> <code>dict</code> <p>Dictionary to store the tracked variables over time.</p> required <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The model object from which data is being tracked.</p>"},{"location":"api/Variable2DTracker/#finitewave.cpuwave2D.tracker.variable_2d_tracker.Variable2DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the tracker with the given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The model object from which data is being tracked. It must have attributes <code>t_max</code> (total simulation time) and <code>dt</code> (time step) to determine the length of the tracking arrays.</p> required"},{"location":"api/Variable2DTracker/#finitewave.cpuwave2D.tracker.variable_2d_tracker.Variable2DTracker.track","title":"<code>track()</code>","text":"<p>Updates the tracked variable values at the specified cell index for the current step.</p>"},{"location":"api/Variable2DTracker/#finitewave.cpuwave2D.tracker.variable_2d_tracker.Variable2DTracker.write","title":"<code>write()</code>","text":"<p>Saves the tracked variable data to files in the specified directory. Creates the directory if it does not exist.</p>"},{"location":"api/Variable3DTracker/","title":"Variable3DTracker","text":"<p>               Bases: <code>Tracker</code></p>"},{"location":"api/Velocity2DTracker/","title":"Velocity2DTracker","text":"<p>               Bases: <code>ActivationTime2DTracker</code></p> <p>A tracker that calculates the front velocity of activation based on activation times from a 2D model. Inherits from <code>ActivationTime2DTracker</code>.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Name of the file where the velocity data will be saved. Default is \"front_velocity\".</p> required"},{"location":"api/Velocity2DTracker/#finitewave.cpuwave2D.tracker.velocity_2d_tracker.Velocity2DTracker.output","title":"<code>output</code>  <code>property</code>","text":"<p>Computes and returns the front velocity of activation.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>2D array of velocities at the front of activation.</p>"},{"location":"api/Velocity2DTracker/#finitewave.cpuwave2D.tracker.velocity_2d_tracker.Velocity2DTracker.compute_velocity_front","title":"<code>compute_velocity_front()</code>","text":"<p>Computes the front velocity of activation based on the activation times.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>2D array of velocities at the front of activation.</p>"},{"location":"api/Velocity2DTracker/#finitewave.cpuwave2D.tracker.velocity_2d_tracker.Velocity2DTracker.initialize","title":"<code>initialize(model)</code>","text":"<p>Initializes the tracker with the given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The model object from which data is being tracked. It must have attributes <code>dr</code> (distance resolution) for computing velocities.</p> required"},{"location":"api/Velocity2DTracker/#finitewave.cpuwave2D.tracker.velocity_2d_tracker.Velocity2DTracker.write","title":"<code>write()</code>","text":"<p>Writes the computed front velocities to a JSON file.</p>"},{"location":"api/Velocity3DTracker/","title":"Velocity3DTracker","text":"<p>               Bases: <code>ActivationTime3DTracker</code></p>"},{"location":"api/VisMeshBuilder3D/","title":"VisMeshBuilder3D","text":"<p>Class to build a 3D mesh for visualization with pyvista.</p> <p>Attributes:     grid (pv.UnstructuredGrid): pyvista Unstructured Grid.</p>"},{"location":"api/VisMeshBuilder3D/#finitewave.tools.vis_mesh_builder_3d.VisMeshBuilder3D.add_scalar","title":"<code>add_scalar(scalars, name='Scalars')</code>","text":"<p>Add a scalar field to the mesh. The scalar field is flattened and only the values of the non-empty space are added to the mesh.</p> <p>Args:     scalar (np.array): 3D scalar field.     name (str): Name of the scalar.</p> <p>Returns:     grid (pv.UnstructuredGrid): pyvista Unstructured Grid.</p>"},{"location":"api/VisMeshBuilder3D/#finitewave.tools.vis_mesh_builder_3d.VisMeshBuilder3D.add_vector","title":"<code>add_vector(vectors, name='Vectors')</code>","text":"<p>Add a vector field to the mesh. The vector field is flattened and only the values of the non-empty space are added to the mesh.</p> <p>Args:     vectors (np.array): 3D vector field.     name (str): Name of the vector.</p> <p>Returns:     grid (pv.UnstructuredGrid): pyvista Unstructured Grid.</p>"},{"location":"api/VisMeshBuilder3D/#finitewave.tools.vis_mesh_builder_3d.VisMeshBuilder3D.build_mesh","title":"<code>build_mesh(mesh)</code>","text":"<p>Build a Unstructured Grid from 3D mesh where mesh &gt; 0.</p> <p>Args:     mesh (np.array): 3D mesh with cardiomyocytes (elems = 1),         empty space (elems = 0), and fibrosis (elems = 2).</p> <p>Returns:     grid (pv.UnstructuredGrid): pyvista Unstructured Grid.</p>"}]}